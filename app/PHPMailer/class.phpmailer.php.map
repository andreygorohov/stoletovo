{"version":3,"names":[],"mappings":"","sources":["PHPMailer/class.phpmailer.php"],"sourcesContent":["<?php\n/**\n * PHPMailer - PHP email creation and transport class.\n * PHP Version 5\n * @package PHPMailer\n * @link https://github.com/PHPMailer/PHPMailer/ The PHPMailer GitHub project\n * @author Marcus Bointon (Synchro/coolbru) <phpmailer@synchromedia.co.uk>\n * @author Jim Jagielski (jimjag) <jimjag@gmail.com>\n * @author Andy Prevost (codeworxtech) <codeworxtech@users.sourceforge.net>\n * @author Brent R. Matzelle (original founder)\n * @copyright 2012 - 2014 Marcus Bointon\n * @copyright 2010 - 2012 Jim Jagielski\n * @copyright 2004 - 2009 Andy Prevost\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n * @note This program is distributed in the hope that it will be useful - WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/**\n * PHPMailer - PHP email creation and transport class.\n * @package PHPMailer\n * @author Marcus Bointon (Synchro/coolbru) <phpmailer@synchromedia.co.uk>\n * @author Jim Jagielski (jimjag) <jimjag@gmail.com>\n * @author Andy Prevost (codeworxtech) <codeworxtech@users.sourceforge.net>\n * @author Brent R. Matzelle (original founder)\n */\nclass PHPMailer\n{\n    /**\n     * The PHPMailer Version number.\n     * @var string\n     */\n    public $Version = '5.2.27';\n\n    /**\n     * Email priority.\n     * Options: null (default), 1 = High, 3 = Normal, 5 = low.\n     * When null, the header is not set at all.\n     * @var integer\n     */\n    public $Priority = null;\n\n    /**\n     * The character set of the message.\n     * @var string\n     */\n    public $CharSet = 'iso-8859-1';\n\n    /**\n     * The MIME Content-type of the message.\n     * @var string\n     */\n    public $ContentType = 'text/plain';\n\n    /**\n     * The message encoding.\n     * Options: \"8bit\", \"7bit\", \"binary\", \"base64\", and \"quoted-printable\".\n     * @var string\n     */\n    public $Encoding = '8bit';\n\n    /**\n     * Holds the most recent mailer error message.\n     * @var string\n     */\n    public $ErrorInfo = '';\n\n    /**\n     * The From email address for the message.\n     * @var string\n     */\n    public $From = 'root@localhost';\n\n    /**\n     * The From name of the message.\n     * @var string\n     */\n    public $FromName = 'Root User';\n\n    /**\n     * The Sender email (Return-Path) of the message.\n     * If not empty, will be sent via -f to sendmail or as 'MAIL FROM' in smtp mode.\n     * @var string\n     */\n    public $Sender = '';\n\n    /**\n     * The Return-Path of the message.\n     * If empty, it will be set to either From or Sender.\n     * @var string\n     * @deprecated Email senders should never set a return-path header;\n     * it's the receiver's job (RFC5321 section 4.4), so this no longer does anything.\n     * @link https://tools.ietf.org/html/rfc5321#section-4.4 RFC5321 reference\n     */\n    public $ReturnPath = '';\n\n    /**\n     * The Subject of the message.\n     * @var string\n     */\n    public $Subject = '';\n\n    /**\n     * An HTML or plain text message body.\n     * If HTML then call isHTML(true).\n     * @var string\n     */\n    public $Body = '';\n\n    /**\n     * The plain-text message body.\n     * This body can be read by mail clients that do not have HTML email\n     * capability such as mutt & Eudora.\n     * Clients that can read HTML will view the normal Body.\n     * @var string\n     */\n    public $AltBody = '';\n\n    /**\n     * An iCal message part body.\n     * Only supported in simple alt or alt_inline message types\n     * To generate iCal events, use the bundled extras/EasyPeasyICS.php class or iCalcreator\n     * @link http://sprain.ch/blog/downloads/php-class-easypeasyics-create-ical-files-with-php/\n     * @link http://kigkonsult.se/iCalcreator/\n     * @var string\n     */\n    public $Ical = '';\n\n    /**\n     * The complete compiled MIME message body.\n     * @access protected\n     * @var string\n     */\n    protected $MIMEBody = '';\n\n    /**\n     * The complete compiled MIME message headers.\n     * @var string\n     * @access protected\n     */\n    protected $MIMEHeader = '';\n\n    /**\n     * Extra headers that createHeader() doesn't fold in.\n     * @var string\n     * @access protected\n     */\n    protected $mailHeader = '';\n\n    /**\n     * Word-wrap the message body to this number of chars.\n     * Set to 0 to not wrap. A useful value here is 78, for RFC2822 section 2.1.1 compliance.\n     * @var integer\n     */\n    public $WordWrap = 0;\n\n    /**\n     * Which method to use to send mail.\n     * Options: \"mail\", \"sendmail\", or \"smtp\".\n     * @var string\n     */\n    public $Mailer = 'mail';\n\n    /**\n     * The path to the sendmail program.\n     * @var string\n     */\n    public $Sendmail = '/usr/sbin/sendmail';\n\n    /**\n     * Whether mail() uses a fully sendmail-compatible MTA.\n     * One which supports sendmail's \"-oi -f\" options.\n     * @var boolean\n     */\n    public $UseSendmailOptions = true;\n\n    /**\n     * Path to PHPMailer plugins.\n     * Useful if the SMTP class is not in the PHP include path.\n     * @var string\n     * @deprecated Should not be needed now there is an autoloader.\n     */\n    public $PluginDir = '';\n\n    /**\n     * The email address that a reading confirmation should be sent to, also known as read receipt.\n     * @var string\n     */\n    public $ConfirmReadingTo = '';\n\n    /**\n     * The hostname to use in the Message-ID header and as default HELO string.\n     * If empty, PHPMailer attempts to find one with, in order,\n     * $_SERVER['SERVER_NAME'], gethostname(), php_uname('n'), or the value\n     * 'localhost.localdomain'.\n     * @var string\n     */\n    public $Hostname = '';\n\n    /**\n     * An ID to be used in the Message-ID header.\n     * If empty, a unique id will be generated.\n     * You can set your own, but it must be in the format \"<id@domain>\",\n     * as defined in RFC5322 section 3.6.4 or it will be ignored.\n     * @see https://tools.ietf.org/html/rfc5322#section-3.6.4\n     * @var string\n     */\n    public $MessageID = '';\n\n    /**\n     * The message Date to be used in the Date header.\n     * If empty, the current date will be added.\n     * @var string\n     */\n    public $MessageDate = '';\n\n    /**\n     * SMTP hosts.\n     * Either a single hostname or multiple semicolon-delimited hostnames.\n     * You can also specify a different port\n     * for each host by using this format: [hostname:port]\n     * (e.g. \"smtp1.example.com:25;smtp2.example.com\").\n     * You can also specify encryption type, for example:\n     * (e.g. \"tls://smtp1.example.com:587;ssl://smtp2.example.com:465\").\n     * Hosts will be tried in order.\n     * @var string\n     */\n    public $Host = 'localhost';\n\n    /**\n     * The default SMTP server port.\n     * @var integer\n     * @TODO Why is this needed when the SMTP class takes care of it?\n     */\n    public $Port = 25;\n\n    /**\n     * The SMTP HELO of the message.\n     * Default is $Hostname. If $Hostname is empty, PHPMailer attempts to find\n     * one with the same method described above for $Hostname.\n     * @var string\n     * @see PHPMailer::$Hostname\n     */\n    public $Helo = '';\n\n    /**\n     * What kind of encryption to use on the SMTP connection.\n     * Options: '', 'ssl' or 'tls'\n     * @var string\n     */\n    public $SMTPSecure = '';\n\n    /**\n     * Whether to enable TLS encryption automatically if a server supports it,\n     * even if `SMTPSecure` is not set to 'tls'.\n     * Be aware that in PHP >= 5.6 this requires that the server's certificates are valid.\n     * @var boolean\n     */\n    public $SMTPAutoTLS = true;\n\n    /**\n     * Whether to use SMTP authentication.\n     * Uses the Username and Password properties.\n     * @var boolean\n     * @see PHPMailer::$Username\n     * @see PHPMailer::$Password\n     */\n    public $SMTPAuth = false;\n\n    /**\n     * Options array passed to stream_context_create when connecting via SMTP.\n     * @var array\n     */\n    public $SMTPOptions = array();\n\n    /**\n     * SMTP username.\n     * @var string\n     */\n    public $Username = '';\n\n    /**\n     * SMTP password.\n     * @var string\n     */\n    public $Password = '';\n\n    /**\n     * SMTP auth type.\n     * Options are CRAM-MD5, LOGIN, PLAIN, NTLM, XOAUTH2, attempted in that order if not specified\n     * @var string\n     */\n    public $AuthType = '';\n\n    /**\n     * SMTP realm.\n     * Used for NTLM auth\n     * @var string\n     */\n    public $Realm = '';\n\n    /**\n     * SMTP workstation.\n     * Used for NTLM auth\n     * @var string\n     */\n    public $Workstation = '';\n\n    /**\n     * The SMTP server timeout in seconds.\n     * Default of 5 minutes (300sec) is from RFC2821 section 4.5.3.2\n     * @var integer\n     */\n    public $Timeout = 300;\n\n    /**\n     * SMTP class debug output mode.\n     * Debug output level.\n     * Options:\n     * * `0` No output\n     * * `1` Commands\n     * * `2` Data and commands\n     * * `3` As 2 plus connection status\n     * * `4` Low-level data output\n     * @var integer\n     * @see SMTP::$do_debug\n     */\n    public $SMTPDebug = 0;\n\n    /**\n     * How to handle debug output.\n     * Options:\n     * * `echo` Output plain-text as-is, appropriate for CLI\n     * * `html` Output escaped, line breaks converted to `<br>`, appropriate for browser output\n     * * `error_log` Output to error log as configured in php.ini\n     *\n     * Alternatively, you can provide a callable expecting two params: a message string and the debug level:\n     * <code>\n     * $mail->Debugoutput = function($str, $level) {echo \"debug level $level; message: $str\";};\n     * </code>\n     * @var string|callable\n     * @see SMTP::$Debugoutput\n     */\n    public $Debugoutput = 'echo';\n\n    /**\n     * Whether to keep SMTP connection open after each message.\n     * If this is set to true then to close the connection\n     * requires an explicit call to smtpClose().\n     * @var boolean\n     */\n    public $SMTPKeepAlive = false;\n\n    /**\n     * Whether to split multiple to addresses into multiple messages\n     * or send them all in one message.\n     * Only supported in `mail` and `sendmail` transports, not in SMTP.\n     * @var boolean\n     */\n    public $SingleTo = false;\n\n    /**\n     * Storage for addresses when SingleTo is enabled.\n     * @var array\n     * @TODO This should really not be public\n     */\n    public $SingleToArray = array();\n\n    /**\n     * Whether to generate VERP addresses on send.\n     * Only applicable when sending via SMTP.\n     * @link https://en.wikipedia.org/wiki/Variable_envelope_return_path\n     * @link http://www.postfix.org/VERP_README.html Postfix VERP info\n     * @var boolean\n     */\n    public $do_verp = false;\n\n    /**\n     * Whether to allow sending messages with an empty body.\n     * @var boolean\n     */\n    public $AllowEmpty = false;\n\n    /**\n     * The default line ending.\n     * @note The default remains \"\\n\". We force CRLF where we know\n     *        it must be used via self::CRLF.\n     * @var string\n     */\n    public $LE = \"\\n\";\n\n    /**\n     * DKIM selector.\n     * @var string\n     */\n    public $DKIM_selector = '';\n\n    /**\n     * DKIM Identity.\n     * Usually the email address used as the source of the email.\n     * @var string\n     */\n    public $DKIM_identity = '';\n\n    /**\n     * DKIM passphrase.\n     * Used if your key is encrypted.\n     * @var string\n     */\n    public $DKIM_passphrase = '';\n\n    /**\n     * DKIM signing domain name.\n     * @example 'example.com'\n     * @var string\n     */\n    public $DKIM_domain = '';\n\n    /**\n     * DKIM private key file path.\n     * @var string\n     */\n    public $DKIM_private = '';\n\n    /**\n     * DKIM private key string.\n     * If set, takes precedence over `$DKIM_private`.\n     * @var string\n     */\n    public $DKIM_private_string = '';\n\n    /**\n     * Callback Action function name.\n     *\n     * The function that handles the result of the send email action.\n     * It is called out by send() for each email sent.\n     *\n     * Value can be any php callable: http://www.php.net/is_callable\n     *\n     * Parameters:\n     *   boolean $result        result of the send action\n     *   array   $to            email addresses of the recipients\n     *   array   $cc            cc email addresses\n     *   array   $bcc           bcc email addresses\n     *   string  $subject       the subject\n     *   string  $body          the email body\n     *   string  $from          email address of sender\n     * @var string\n     */\n    public $action_function = '';\n\n    /**\n     * What to put in the X-Mailer header.\n     * Options: An empty string for PHPMailer default, whitespace for none, or a string to use\n     * @var string\n     */\n    public $XMailer = '';\n\n    /**\n     * Which validator to use by default when validating email addresses.\n     * May be a callable to inject your own validator, but there are several built-in validators.\n     * @see PHPMailer::validateAddress()\n     * @var string|callable\n     * @static\n     */\n    public static $validator = 'auto';\n\n    /**\n     * An instance of the SMTP sender class.\n     * @var SMTP\n     * @access protected\n     */\n    protected $smtp = null;\n\n    /**\n     * The array of 'to' names and addresses.\n     * @var array\n     * @access protected\n     */\n    protected $to = array();\n\n    /**\n     * The array of 'cc' names and addresses.\n     * @var array\n     * @access protected\n     */\n    protected $cc = array();\n\n    /**\n     * The array of 'bcc' names and addresses.\n     * @var array\n     * @access protected\n     */\n    protected $bcc = array();\n\n    /**\n     * The array of reply-to names and addresses.\n     * @var array\n     * @access protected\n     */\n    protected $ReplyTo = array();\n\n    /**\n     * An array of all kinds of addresses.\n     * Includes all of $to, $cc, $bcc\n     * @var array\n     * @access protected\n     * @see PHPMailer::$to @see PHPMailer::$cc @see PHPMailer::$bcc\n     */\n    protected $all_recipients = array();\n\n    /**\n     * An array of names and addresses queued for validation.\n     * In send(), valid and non duplicate entries are moved to $all_recipients\n     * and one of $to, $cc, or $bcc.\n     * This array is used only for addresses with IDN.\n     * @var array\n     * @access protected\n     * @see PHPMailer::$to @see PHPMailer::$cc @see PHPMailer::$bcc\n     * @see PHPMailer::$all_recipients\n     */\n    protected $RecipientsQueue = array();\n\n    /**\n     * An array of reply-to names and addresses queued for validation.\n     * In send(), valid and non duplicate entries are moved to $ReplyTo.\n     * This array is used only for addresses with IDN.\n     * @var array\n     * @access protected\n     * @see PHPMailer::$ReplyTo\n     */\n    protected $ReplyToQueue = array();\n\n    /**\n     * The array of attachments.\n     * @var array\n     * @access protected\n     */\n    protected $attachment = array();\n\n    /**\n     * The array of custom headers.\n     * @var array\n     * @access protected\n     */\n    protected $CustomHeader = array();\n\n    /**\n     * The most recent Message-ID (including angular brackets).\n     * @var string\n     * @access protected\n     */\n    protected $lastMessageID = '';\n\n    /**\n     * The message's MIME type.\n     * @var string\n     * @access protected\n     */\n    protected $message_type = '';\n\n    /**\n     * The array of MIME boundary strings.\n     * @var array\n     * @access protected\n     */\n    protected $boundary = array();\n\n    /**\n     * The array of available languages.\n     * @var array\n     * @access protected\n     */\n    protected $language = array();\n\n    /**\n     * The number of errors encountered.\n     * @var integer\n     * @access protected\n     */\n    protected $error_count = 0;\n\n    /**\n     * The S/MIME certificate file path.\n     * @var string\n     * @access protected\n     */\n    protected $sign_cert_file = '';\n\n    /**\n     * The S/MIME key file path.\n     * @var string\n     * @access protected\n     */\n    protected $sign_key_file = '';\n\n    /**\n     * The optional S/MIME extra certificates (\"CA Chain\") file path.\n     * @var string\n     * @access protected\n     */\n    protected $sign_extracerts_file = '';\n\n    /**\n     * The S/MIME password for the key.\n     * Used only if the key is encrypted.\n     * @var string\n     * @access protected\n     */\n    protected $sign_key_pass = '';\n\n    /**\n     * Whether to throw exceptions for errors.\n     * @var boolean\n     * @access protected\n     */\n    protected $exceptions = false;\n\n    /**\n     * Unique ID used for message ID and boundaries.\n     * @var string\n     * @access protected\n     */\n    protected $uniqueid = '';\n\n    /**\n     * Error severity: message only, continue processing.\n     */\n    const STOP_MESSAGE = 0;\n\n    /**\n     * Error severity: message, likely ok to continue processing.\n     */\n    const STOP_CONTINUE = 1;\n\n    /**\n     * Error severity: message, plus full stop, critical error reached.\n     */\n    const STOP_CRITICAL = 2;\n\n    /**\n     * SMTP RFC standard line ending.\n     */\n    const CRLF = \"\\r\\n\";\n\n    /**\n     * The maximum line length allowed by RFC 2822 section 2.1.1\n     * @var integer\n     */\n    const MAX_LINE_LENGTH = 998;\n\n    /**\n     * Constructor.\n     * @param boolean $exceptions Should we throw external exceptions?\n     */\n    public function __construct($exceptions = null)\n    {\n        if ($exceptions !== null) {\n            $this->exceptions = (boolean)$exceptions;\n        }\n        //Pick an appropriate debug output format automatically\n        $this->Debugoutput = (strpos(PHP_SAPI, 'cli') !== false ? 'echo' : 'html');\n    }\n\n    /**\n     * Destructor.\n     */\n    public function __destruct()\n    {\n        //Close any open SMTP connection nicely\n        $this->smtpClose();\n    }\n\n    /**\n     * Call mail() in a safe_mode-aware fashion.\n     * Also, unless sendmail_path points to sendmail (or something that\n     * claims to be sendmail), don't pass params (not a perfect fix,\n     * but it will do)\n     * @param string $to To\n     * @param string $subject Subject\n     * @param string $body Message Body\n     * @param string $header Additional Header(s)\n     * @param string $params Params\n     * @access private\n     * @return boolean\n     */\n    private function mailPassthru($to, $subject, $body, $header, $params)\n    {\n        //Check overloading of mail function to avoid double-encoding\n        if (ini_get('mbstring.func_overload') & 1) {\n            $subject = $this->secureHeader($subject);\n        } else {\n            $subject = $this->encodeHeader($this->secureHeader($subject));\n        }\n\n        //Can't use additional_parameters in safe_mode, calling mail() with null params breaks\n        //@link http://php.net/manual/en/function.mail.php\n        if (ini_get('safe_mode') or !$this->UseSendmailOptions or is_null($params)) {\n            $result = @mail($to, $subject, $body, $header);\n        } else {\n            $result = @mail($to, $subject, $body, $header, $params);\n        }\n        return $result;\n    }\n    /**\n     * Output debugging info via user-defined method.\n     * Only generates output if SMTP debug output is enabled (@see SMTP::$do_debug).\n     * @see PHPMailer::$Debugoutput\n     * @see PHPMailer::$SMTPDebug\n     * @param string $str\n     */\n    protected function edebug($str)\n    {\n        if ($this->SMTPDebug <= 0) {\n            return;\n        }\n        //Avoid clash with built-in function names\n        if (!in_array($this->Debugoutput, array('error_log', 'html', 'echo')) and is_callable($this->Debugoutput)) {\n            call_user_func($this->Debugoutput, $str, $this->SMTPDebug);\n            return;\n        }\n        switch ($this->Debugoutput) {\n            case 'error_log':\n                //Don't output, just log\n                error_log($str);\n                break;\n            case 'html':\n                //Cleans up output a bit for a better looking, HTML-safe output\n                echo htmlentities(\n                    preg_replace('/[\\r\\n]+/', '', $str),\n                    ENT_QUOTES,\n                    'UTF-8'\n                )\n                . \"<br>\\n\";\n                break;\n            case 'echo':\n            default:\n                //Normalize line breaks\n                $str = preg_replace('/\\r\\n?/ms', \"\\n\", $str);\n                echo gmdate('Y-m-d H:i:s') . \"\\t\" . str_replace(\n                    \"\\n\",\n                    \"\\n                   \\t                  \",\n                    trim($str)\n                ) . \"\\n\";\n        }\n    }\n\n    /**\n     * Sets message type to HTML or plain.\n     * @param boolean $isHtml True for HTML mode.\n     * @return void\n     */\n    public function isHTML($isHtml = true)\n    {\n        if ($isHtml) {\n            $this->ContentType = 'text/html';\n        } else {\n            $this->ContentType = 'text/plain';\n        }\n    }\n\n    /**\n     * Send messages using SMTP.\n     * @return void\n     */\n    public function isSMTP()\n    {\n        $this->Mailer = 'smtp';\n    }\n\n    /**\n     * Send messages using PHP's mail() function.\n     * @return void\n     */\n    public function isMail()\n    {\n        $this->Mailer = 'mail';\n    }\n\n    /**\n     * Send messages using $Sendmail.\n     * @return void\n     */\n    public function isSendmail()\n    {\n        $ini_sendmail_path = ini_get('sendmail_path');\n\n        if (!stristr($ini_sendmail_path, 'sendmail')) {\n            $this->Sendmail = '/usr/sbin/sendmail';\n        } else {\n            $this->Sendmail = $ini_sendmail_path;\n        }\n        $this->Mailer = 'sendmail';\n    }\n\n    /**\n     * Send messages using qmail.\n     * @return void\n     */\n    public function isQmail()\n    {\n        $ini_sendmail_path = ini_get('sendmail_path');\n\n        if (!stristr($ini_sendmail_path, 'qmail')) {\n            $this->Sendmail = '/var/qmail/bin/qmail-inject';\n        } else {\n            $this->Sendmail = $ini_sendmail_path;\n        }\n        $this->Mailer = 'qmail';\n    }\n\n    /**\n     * Add a \"To\" address.\n     * @param string $address The email address to send to\n     * @param string $name\n     * @return boolean true on success, false if address already used or invalid in some way\n     */\n    public function addAddress($address, $name = '')\n    {\n        return $this->addOrEnqueueAnAddress('to', $address, $name);\n    }\n\n    /**\n     * Add a \"CC\" address.\n     * @note: This function works with the SMTP mailer on win32, not with the \"mail\" mailer.\n     * @param string $address The email address to send to\n     * @param string $name\n     * @return boolean true on success, false if address already used or invalid in some way\n     */\n    public function addCC($address, $name = '')\n    {\n        return $this->addOrEnqueueAnAddress('cc', $address, $name);\n    }\n\n    /**\n     * Add a \"BCC\" address.\n     * @note: This function works with the SMTP mailer on win32, not with the \"mail\" mailer.\n     * @param string $address The email address to send to\n     * @param string $name\n     * @return boolean true on success, false if address already used or invalid in some way\n     */\n    public function addBCC($address, $name = '')\n    {\n        return $this->addOrEnqueueAnAddress('bcc', $address, $name);\n    }\n\n    /**\n     * Add a \"Reply-To\" address.\n     * @param string $address The email address to reply to\n     * @param string $name\n     * @return boolean true on success, false if address already used or invalid in some way\n     */\n    public function addReplyTo($address, $name = '')\n    {\n        return $this->addOrEnqueueAnAddress('Reply-To', $address, $name);\n    }\n\n    /**\n     * Add an address to one of the recipient arrays or to the ReplyTo array. Because PHPMailer\n     * can't validate addresses with an IDN without knowing the PHPMailer::$CharSet (that can still\n     * be modified after calling this function), addition of such addresses is delayed until send().\n     * Addresses that have been added already return false, but do not throw exceptions.\n     * @param string $kind One of 'to', 'cc', 'bcc', or 'ReplyTo'\n     * @param string $address The email address to send, resp. to reply to\n     * @param string $name\n     * @throws phpmailerException\n     * @return boolean true on success, false if address already used or invalid in some way\n     * @access protected\n     */\n    protected function addOrEnqueueAnAddress($kind, $address, $name)\n    {\n        $address = trim($address);\n        $name = trim(preg_replace('/[\\r\\n]+/', '', $name)); //Strip breaks and trim\n        if (($pos = strrpos($address, '@')) === false) {\n            // At-sign is misssing.\n            $error_message = $this->lang('invalid_address') . \" (addAnAddress $kind): $address\";\n            $this->setError($error_message);\n            $this->edebug($error_message);\n            if ($this->exceptions) {\n                throw new phpmailerException($error_message);\n            }\n            return false;\n        }\n        $params = array($kind, $address, $name);\n        // Enqueue addresses with IDN until we know the PHPMailer::$CharSet.\n        if ($this->has8bitChars(substr($address, ++$pos)) and $this->idnSupported()) {\n            if ($kind != 'Reply-To') {\n                if (!array_key_exists($address, $this->RecipientsQueue)) {\n                    $this->RecipientsQueue[$address] = $params;\n                    return true;\n                }\n            } else {\n                if (!array_key_exists($address, $this->ReplyToQueue)) {\n                    $this->ReplyToQueue[$address] = $params;\n                    return true;\n                }\n            }\n            return false;\n        }\n        // Immediately add standard addresses without IDN.\n        return call_user_func_array(array($this, 'addAnAddress'), $params);\n    }\n\n    /**\n     * Add an address to one of the recipient arrays or to the ReplyTo array.\n     * Addresses that have been added already return false, but do not throw exceptions.\n     * @param string $kind One of 'to', 'cc', 'bcc', or 'ReplyTo'\n     * @param string $address The email address to send, resp. to reply to\n     * @param string $name\n     * @throws phpmailerException\n     * @return boolean true on success, false if address already used or invalid in some way\n     * @access protected\n     */\n    protected function addAnAddress($kind, $address, $name = '')\n    {\n        if (!in_array($kind, array('to', 'cc', 'bcc', 'Reply-To'))) {\n            $error_message = $this->lang('Invalid recipient kind: ') . $kind;\n            $this->setError($error_message);\n            $this->edebug($error_message);\n            if ($this->exceptions) {\n                throw new phpmailerException($error_message);\n            }\n            return false;\n        }\n        if (!$this->validateAddress($address)) {\n            $error_message = $this->lang('invalid_address') . \" (addAnAddress $kind): $address\";\n            $this->setError($error_message);\n            $this->edebug($error_message);\n            if ($this->exceptions) {\n                throw new phpmailerException($error_message);\n            }\n            return false;\n        }\n        if ($kind != 'Reply-To') {\n            if (!array_key_exists(strtolower($address), $this->all_recipients)) {\n                array_push($this->$kind, array($address, $name));\n                $this->all_recipients[strtolower($address)] = true;\n                return true;\n            }\n        } else {\n            if (!array_key_exists(strtolower($address), $this->ReplyTo)) {\n                $this->ReplyTo[strtolower($address)] = array($address, $name);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Parse and validate a string containing one or more RFC822-style comma-separated email addresses\n     * of the form \"display name <address>\" into an array of name/address pairs.\n     * Uses the imap_rfc822_parse_adrlist function if the IMAP extension is available.\n     * Note that quotes in the name part are removed.\n     * @param string $addrstr The address list string\n     * @param bool $useimap Whether to use the IMAP extension to parse the list\n     * @return array\n     * @link http://www.andrew.cmu.edu/user/agreen1/testing/mrbs/web/Mail/RFC822.php A more careful implementation\n     */\n    public function parseAddresses($addrstr, $useimap = true)\n    {\n        $addresses = array();\n        if ($useimap and function_exists('imap_rfc822_parse_adrlist')) {\n            //Use this built-in parser if it's available\n            $list = imap_rfc822_parse_adrlist($addrstr, '');\n            foreach ($list as $address) {\n                if ($address->host != '.SYNTAX-ERROR.') {\n                    if ($this->validateAddress($address->mailbox . '@' . $address->host)) {\n                        $addresses[] = array(\n                            'name' => (property_exists($address, 'personal') ? $address->personal : ''),\n                            'address' => $address->mailbox . '@' . $address->host\n                        );\n                    }\n                }\n            }\n        } else {\n            //Use this simpler parser\n            $list = explode(',', $addrstr);\n            foreach ($list as $address) {\n                $address = trim($address);\n                //Is there a separate name part?\n                if (strpos($address, '<') === false) {\n                    //No separate name, just use the whole thing\n                    if ($this->validateAddress($address)) {\n                        $addresses[] = array(\n                            'name' => '',\n                            'address' => $address\n                        );\n                    }\n                } else {\n                    list($name, $email) = explode('<', $address);\n                    $email = trim(str_replace('>', '', $email));\n                    if ($this->validateAddress($email)) {\n                        $addresses[] = array(\n                            'name' => trim(str_replace(array('\"', \"'\"), '', $name)),\n                            'address' => $email\n                        );\n                    }\n                }\n            }\n        }\n        return $addresses;\n    }\n\n    /**\n     * Set the From and FromName properties.\n     * @param string $address\n     * @param string $name\n     * @param boolean $auto Whether to also set the Sender address, defaults to true\n     * @throws phpmailerException\n     * @return boolean\n     */\n    public function setFrom($address, $name = '', $auto = true)\n    {\n        $address = trim($address);\n        $name = trim(preg_replace('/[\\r\\n]+/', '', $name)); //Strip breaks and trim\n        // Don't validate now addresses with IDN. Will be done in send().\n        if (($pos = strrpos($address, '@')) === false or\n            (!$this->has8bitChars(substr($address, ++$pos)) or !$this->idnSupported()) and\n            !$this->validateAddress($address)) {\n            $error_message = $this->lang('invalid_address') . \" (setFrom) $address\";\n            $this->setError($error_message);\n            $this->edebug($error_message);\n            if ($this->exceptions) {\n                throw new phpmailerException($error_message);\n            }\n            return false;\n        }\n        $this->From = $address;\n        $this->FromName = $name;\n        if ($auto) {\n            if (empty($this->Sender)) {\n                $this->Sender = $address;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return the Message-ID header of the last email.\n     * Technically this is the value from the last time the headers were created,\n     * but it's also the message ID of the last sent message except in\n     * pathological cases.\n     * @return string\n     */\n    public function getLastMessageID()\n    {\n        return $this->lastMessageID;\n    }\n\n    /**\n     * Check that a string looks like an email address.\n     * @param string $address The email address to check\n     * @param string|callable $patternselect A selector for the validation pattern to use :\n     * * `auto` Pick best pattern automatically;\n     * * `pcre8` Use the squiloople.com pattern, requires PCRE > 8.0, PHP >= 5.3.2, 5.2.14;\n     * * `pcre` Use old PCRE implementation;\n     * * `php` Use PHP built-in FILTER_VALIDATE_EMAIL;\n     * * `html5` Use the pattern given by the HTML5 spec for 'email' type form input elements.\n     * * `noregex` Don't use a regex: super fast, really dumb.\n     * Alternatively you may pass in a callable to inject your own validator, for example:\n     * PHPMailer::validateAddress('user@example.com', function($address) {\n     *     return (strpos($address, '@') !== false);\n     * });\n     * You can also set the PHPMailer::$validator static to a callable, allowing built-in methods to use your validator.\n     * @return boolean\n     * @static\n     * @access public\n     */\n    public static function validateAddress($address, $patternselect = null)\n    {\n        if (is_null($patternselect)) {\n            $patternselect = self::$validator;\n        }\n        if (is_callable($patternselect)) {\n            return call_user_func($patternselect, $address);\n        }\n        //Reject line breaks in addresses; it's valid RFC5322, but not RFC5321\n        if (strpos($address, \"\\n\") !== false or strpos($address, \"\\r\") !== false) {\n            return false;\n        }\n        if (!$patternselect or $patternselect == 'auto') {\n            //Check this constant first so it works when extension_loaded() is disabled by safe mode\n            //Constant was added in PHP 5.2.4\n            if (defined('PCRE_VERSION')) {\n                //This pattern can get stuck in a recursive loop in PCRE <= 8.0.2\n                if (version_compare(PCRE_VERSION, '8.0.3') >= 0) {\n                    $patternselect = 'pcre8';\n                } else {\n                    $patternselect = 'pcre';\n                }\n            } elseif (function_exists('extension_loaded') and extension_loaded('pcre')) {\n                //Fall back to older PCRE\n                $patternselect = 'pcre';\n            } else {\n                //Filter_var appeared in PHP 5.2.0 and does not require the PCRE extension\n                if (version_compare(PHP_VERSION, '5.2.0') >= 0) {\n                    $patternselect = 'php';\n                } else {\n                    $patternselect = 'noregex';\n                }\n            }\n        }\n        switch ($patternselect) {\n            case 'pcre8':\n                /**\n                 * Uses the same RFC5322 regex on which FILTER_VALIDATE_EMAIL is based, but allows dotless domains.\n                 * @link http://squiloople.com/2009/12/20/email-address-validation/\n                 * @copyright 2009-2010 Michael Rushton\n                 * Feel free to use and redistribute this code. But please keep this copyright notice.\n                 */\n                return (boolean)preg_match(\n                    '/^(?!(?>(?1)\"?(?>\\\\\\[ -~]|[^\"])\"?(?1)){255,})(?!(?>(?1)\"?(?>\\\\\\[ -~]|[^\"])\"?(?1)){65,}@)' .\n                    '((?>(?>(?>((?>(?>(?>\\x0D\\x0A)?[\\t ])+|(?>[\\t ]*\\x0D\\x0A)?[\\t ]+)?)(\\((?>(?2)' .\n                    '(?>[\\x01-\\x08\\x0B\\x0C\\x0E-\\'*-\\[\\]-\\x7F]|\\\\\\[\\x00-\\x7F]|(?3)))*(?2)\\)))+(?2))|(?2))?)' .\n                    '([!#-\\'*+\\/-9=?^-~-]+|\"(?>(?2)(?>[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\x7F]))*' .\n                    '(?2)\")(?>(?1)\\.(?1)(?4))*(?1)@(?!(?1)[a-z0-9-]{64,})(?1)(?>([a-z0-9](?>[a-z0-9-]*[a-z0-9])?)' .\n                    '(?>(?1)\\.(?!(?1)[a-z0-9-]{64,})(?1)(?5)){0,126}|\\[(?:(?>IPv6:(?>([a-f0-9]{1,4})(?>:(?6)){7}' .\n                    '|(?!(?:.*[a-f0-9][:\\]]){8,})((?6)(?>:(?6)){0,6})?::(?7)?))|(?>(?>IPv6:(?>(?6)(?>:(?6)){5}:' .\n                    '|(?!(?:.*[a-f0-9]:){6,})(?8)?::(?>((?6)(?>:(?6)){0,4}):)?))?(25[0-5]|2[0-4][0-9]|1[0-9]{2}' .\n                    '|[1-9]?[0-9])(?>\\.(?9)){3}))\\])(?1)$/isD',\n                    $address\n                );\n            case 'pcre':\n                //An older regex that doesn't need a recent PCRE\n                return (boolean)preg_match(\n                    '/^(?!(?>\"?(?>\\\\\\[ -~]|[^\"])\"?){255,})(?!(?>\"?(?>\\\\\\[ -~]|[^\"])\"?){65,}@)(?>' .\n                    '[!#-\\'*+\\/-9=?^-~-]+|\"(?>(?>[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\xFF]))*\")' .\n                    '(?>\\.(?>[!#-\\'*+\\/-9=?^-~-]+|\"(?>(?>[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\xFF]))*\"))*' .\n                    '@(?>(?![a-z0-9-]{64,})(?>[a-z0-9](?>[a-z0-9-]*[a-z0-9])?)(?>\\.(?![a-z0-9-]{64,})' .\n                    '(?>[a-z0-9](?>[a-z0-9-]*[a-z0-9])?)){0,126}|\\[(?:(?>IPv6:(?>(?>[a-f0-9]{1,4})(?>:' .\n                    '[a-f0-9]{1,4}){7}|(?!(?:.*[a-f0-9][:\\]]){8,})(?>[a-f0-9]{1,4}(?>:[a-f0-9]{1,4}){0,6})?' .\n                    '::(?>[a-f0-9]{1,4}(?>:[a-f0-9]{1,4}){0,6})?))|(?>(?>IPv6:(?>[a-f0-9]{1,4}(?>:' .\n                    '[a-f0-9]{1,4}){5}:|(?!(?:.*[a-f0-9]:){6,})(?>[a-f0-9]{1,4}(?>:[a-f0-9]{1,4}){0,4})?' .\n                    '::(?>(?:[a-f0-9]{1,4}(?>:[a-f0-9]{1,4}){0,4}):)?))?(?>25[0-5]|2[0-4][0-9]|1[0-9]{2}' .\n                    '|[1-9]?[0-9])(?>\\.(?>25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}))\\])$/isD',\n                    $address\n                );\n            case 'html5':\n                /**\n                 * This is the pattern used in the HTML5 spec for validation of 'email' type form input elements.\n                 * @link http://www.whatwg.org/specs/web-apps/current-work/#e-mail-state-(type=email)\n                 */\n                return (boolean)preg_match(\n                    '/^[a-zA-Z0-9.!#$%&\\'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}' .\n                    '[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/sD',\n                    $address\n                );\n            case 'noregex':\n                //No PCRE! Do something _very_ approximate!\n                //Check the address is 3 chars or longer and contains an @ that's not the first or last char\n                return (strlen($address) >= 3\n                    and strpos($address, '@') >= 1\n                    and strpos($address, '@') != strlen($address) - 1);\n            case 'php':\n            default:\n                return (boolean)filter_var($address, FILTER_VALIDATE_EMAIL);\n        }\n    }\n\n    /**\n     * Tells whether IDNs (Internationalized Domain Names) are supported or not. This requires the\n     * \"intl\" and \"mbstring\" PHP extensions.\n     * @return bool \"true\" if required functions for IDN support are present\n     */\n    public function idnSupported()\n    {\n        // @TODO: Write our own \"idn_to_ascii\" function for PHP <= 5.2.\n        return function_exists('idn_to_ascii') and function_exists('mb_convert_encoding');\n    }\n\n    /**\n     * Converts IDN in given email address to its ASCII form, also known as punycode, if possible.\n     * Important: Address must be passed in same encoding as currently set in PHPMailer::$CharSet.\n     * This function silently returns unmodified address if:\n     * - No conversion is necessary (i.e. domain name is not an IDN, or is already in ASCII form)\n     * - Conversion to punycode is impossible (e.g. required PHP functions are not available)\n     *   or fails for any reason (e.g. domain has characters not allowed in an IDN)\n     * @see PHPMailer::$CharSet\n     * @param string $address The email address to convert\n     * @return string The encoded address in ASCII form\n     */\n    public function punyencodeAddress($address)\n    {\n        // Verify we have required functions, CharSet, and at-sign.\n        if ($this->idnSupported() and\n            !empty($this->CharSet) and\n            ($pos = strrpos($address, '@')) !== false) {\n            $domain = substr($address, ++$pos);\n            // Verify CharSet string is a valid one, and domain properly encoded in this CharSet.\n            if ($this->has8bitChars($domain) and @mb_check_encoding($domain, $this->CharSet)) {\n                $domain = mb_convert_encoding($domain, 'UTF-8', $this->CharSet);\n                if (($punycode = defined('INTL_IDNA_VARIANT_UTS46') ?\n                    idn_to_ascii($domain, 0, INTL_IDNA_VARIANT_UTS46) :\n                    idn_to_ascii($domain)) !== false) {\n                    return substr($address, 0, $pos) . $punycode;\n                }\n            }\n        }\n        return $address;\n    }\n\n    /**\n     * Create a message and send it.\n     * Uses the sending method specified by $Mailer.\n     * @throws phpmailerException\n     * @return boolean false on error - See the ErrorInfo property for details of the error.\n     */\n    public function send()\n    {\n        try {\n            if (!$this->preSend()) {\n                return false;\n            }\n            return $this->postSend();\n        } catch (phpmailerException $exc) {\n            $this->mailHeader = '';\n            $this->setError($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Prepare a message for sending.\n     * @throws phpmailerException\n     * @return boolean\n     */\n    public function preSend()\n    {\n        try {\n            $this->error_count = 0; // Reset errors\n            $this->mailHeader = '';\n\n            // Dequeue recipient and Reply-To addresses with IDN\n            foreach (array_merge($this->RecipientsQueue, $this->ReplyToQueue) as $params) {\n                $params[1] = $this->punyencodeAddress($params[1]);\n                call_user_func_array(array($this, 'addAnAddress'), $params);\n            }\n            if ((count($this->to) + count($this->cc) + count($this->bcc)) < 1) {\n                throw new phpmailerException($this->lang('provide_address'), self::STOP_CRITICAL);\n            }\n\n            // Validate From, Sender, and ConfirmReadingTo addresses\n            foreach (array('From', 'Sender', 'ConfirmReadingTo') as $address_kind) {\n                $this->$address_kind = trim($this->$address_kind);\n                if (empty($this->$address_kind)) {\n                    continue;\n                }\n                $this->$address_kind = $this->punyencodeAddress($this->$address_kind);\n                if (!$this->validateAddress($this->$address_kind)) {\n                    $error_message = $this->lang('invalid_address') . ' (punyEncode) ' . $this->$address_kind;\n                    $this->setError($error_message);\n                    $this->edebug($error_message);\n                    if ($this->exceptions) {\n                        throw new phpmailerException($error_message);\n                    }\n                    return false;\n                }\n            }\n\n            // Set whether the message is multipart/alternative\n            if ($this->alternativeExists()) {\n                $this->ContentType = 'multipart/alternative';\n            }\n\n            $this->setMessageType();\n            // Refuse to send an empty message unless we are specifically allowing it\n            if (!$this->AllowEmpty and empty($this->Body)) {\n                throw new phpmailerException($this->lang('empty_message'), self::STOP_CRITICAL);\n            }\n\n            // Create body before headers in case body makes changes to headers (e.g. altering transfer encoding)\n            $this->MIMEHeader = '';\n            $this->MIMEBody = $this->createBody();\n            // createBody may have added some headers, so retain them\n            $tempheaders = $this->MIMEHeader;\n            $this->MIMEHeader = $this->createHeader();\n            $this->MIMEHeader .= $tempheaders;\n\n            // To capture the complete message when using mail(), create\n            // an extra header list which createHeader() doesn't fold in\n            if ($this->Mailer == 'mail') {\n                if (count($this->to) > 0) {\n                    $this->mailHeader .= $this->addrAppend('To', $this->to);\n                } else {\n                    $this->mailHeader .= $this->headerLine('To', 'undisclosed-recipients:;');\n                }\n                $this->mailHeader .= $this->headerLine(\n                    'Subject',\n                    $this->encodeHeader($this->secureHeader(trim($this->Subject)))\n                );\n            }\n\n            // Sign with DKIM if enabled\n            if (!empty($this->DKIM_domain)\n                and !empty($this->DKIM_selector)\n                and (!empty($this->DKIM_private_string)\n                    or (!empty($this->DKIM_private)\n                        and self::isPermittedPath($this->DKIM_private)\n                        and file_exists($this->DKIM_private)\n                    )\n                )\n            ) {\n                $header_dkim = $this->DKIM_Add(\n                    $this->MIMEHeader . $this->mailHeader,\n                    $this->encodeHeader($this->secureHeader($this->Subject)),\n                    $this->MIMEBody\n                );\n                $this->MIMEHeader = rtrim($this->MIMEHeader, \"\\r\\n \") . self::CRLF .\n                    str_replace(\"\\r\\n\", \"\\n\", $header_dkim) . self::CRLF;\n            }\n            return true;\n        } catch (phpmailerException $exc) {\n            $this->setError($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Actually send a message.\n     * Send the email via the selected mechanism\n     * @throws phpmailerException\n     * @return boolean\n     */\n    public function postSend()\n    {\n        try {\n            // Choose the mailer and send through it\n            switch ($this->Mailer) {\n                case 'sendmail':\n                case 'qmail':\n                    return $this->sendmailSend($this->MIMEHeader, $this->MIMEBody);\n                case 'smtp':\n                    return $this->smtpSend($this->MIMEHeader, $this->MIMEBody);\n                case 'mail':\n                    return $this->mailSend($this->MIMEHeader, $this->MIMEBody);\n                default:\n                    $sendMethod = $this->Mailer.'Send';\n                    if (method_exists($this, $sendMethod)) {\n                        return $this->$sendMethod($this->MIMEHeader, $this->MIMEBody);\n                    }\n\n                    return $this->mailSend($this->MIMEHeader, $this->MIMEBody);\n            }\n        } catch (phpmailerException $exc) {\n            $this->setError($exc->getMessage());\n            $this->edebug($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Send mail using the $Sendmail program.\n     * @param string $header The message headers\n     * @param string $body The message body\n     * @see PHPMailer::$Sendmail\n     * @throws phpmailerException\n     * @access protected\n     * @return boolean\n     */\n    protected function sendmailSend($header, $body)\n    {\n        // CVE-2016-10033, CVE-2016-10045: Don't pass -f if characters will be escaped.\n        if (!empty($this->Sender) and self::isShellSafe($this->Sender)) {\n            if ($this->Mailer == 'qmail') {\n                $sendmailFmt = '%s -f%s';\n            } else {\n                $sendmailFmt = '%s -oi -f%s -t';\n            }\n        } else {\n            if ($this->Mailer == 'qmail') {\n                $sendmailFmt = '%s';\n            } else {\n                $sendmailFmt = '%s -oi -t';\n            }\n        }\n\n        // TODO: If possible, this should be changed to escapeshellarg.  Needs thorough testing.\n        $sendmail = sprintf($sendmailFmt, escapeshellcmd($this->Sendmail), $this->Sender);\n\n        if ($this->SingleTo) {\n            foreach ($this->SingleToArray as $toAddr) {\n                if (!@$mail = popen($sendmail, 'w')) {\n                    throw new phpmailerException($this->lang('execute') . $this->Sendmail, self::STOP_CRITICAL);\n                }\n                fputs($mail, 'To: ' . $toAddr . \"\\n\");\n                fputs($mail, $header);\n                fputs($mail, $body);\n                $result = pclose($mail);\n                $this->doCallback(\n                    ($result == 0),\n                    array($toAddr),\n                    $this->cc,\n                    $this->bcc,\n                    $this->Subject,\n                    $body,\n                    $this->From\n                );\n                if ($result != 0) {\n                    throw new phpmailerException($this->lang('execute') . $this->Sendmail, self::STOP_CRITICAL);\n                }\n            }\n        } else {\n            if (!@$mail = popen($sendmail, 'w')) {\n                throw new phpmailerException($this->lang('execute') . $this->Sendmail, self::STOP_CRITICAL);\n            }\n            fputs($mail, $header);\n            fputs($mail, $body);\n            $result = pclose($mail);\n            $this->doCallback(\n                ($result == 0),\n                $this->to,\n                $this->cc,\n                $this->bcc,\n                $this->Subject,\n                $body,\n                $this->From\n            );\n            if ($result != 0) {\n                throw new phpmailerException($this->lang('execute') . $this->Sendmail, self::STOP_CRITICAL);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Fix CVE-2016-10033 and CVE-2016-10045 by disallowing potentially unsafe shell characters.\n     *\n     * Note that escapeshellarg and escapeshellcmd are inadequate for our purposes, especially on Windows.\n     * @param string $string The string to be validated\n     * @see https://github.com/PHPMailer/PHPMailer/issues/924 CVE-2016-10045 bug report\n     * @access protected\n     * @return boolean\n     */\n    protected static function isShellSafe($string)\n    {\n        // Future-proof\n        if (escapeshellcmd($string) !== $string\n            or !in_array(escapeshellarg($string), array(\"'$string'\", \"\\\"$string\\\"\"))\n        ) {\n            return false;\n        }\n\n        $length = strlen($string);\n\n        for ($i = 0; $i < $length; $i++) {\n            $c = $string[$i];\n\n            // All other characters have a special meaning in at least one common shell, including = and +.\n            // Full stop (.) has a special meaning in cmd.exe, but its impact should be negligible here.\n            // Note that this does permit non-Latin alphanumeric characters based on the current locale.\n            if (!ctype_alnum($c) && strpos('@_-.', $c) === false) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check whether a file path is of a permitted type.\n     * Used to reject URLs and phar files from functions that access local file paths,\n     * such as addAttachment.\n     * @param string $path A relative or absolute path to a file.\n     * @return bool\n     */\n    protected static function isPermittedPath($path)\n    {\n        return !preg_match('#^[a-z]+://#i', $path);\n    }\n\n    /**\n     * Send mail using the PHP mail() function.\n     * @param string $header The message headers\n     * @param string $body The message body\n     * @link http://www.php.net/manual/en/book.mail.php\n     * @throws phpmailerException\n     * @access protected\n     * @return boolean\n     */\n    protected function mailSend($header, $body)\n    {\n        $toArr = array();\n        foreach ($this->to as $toaddr) {\n            $toArr[] = $this->addrFormat($toaddr);\n        }\n        $to = implode(', ', $toArr);\n\n        $params = null;\n        //This sets the SMTP envelope sender which gets turned into a return-path header by the receiver\n        if (!empty($this->Sender) and $this->validateAddress($this->Sender)) {\n            // CVE-2016-10033, CVE-2016-10045: Don't pass -f if characters will be escaped.\n            if (self::isShellSafe($this->Sender)) {\n                $params = sprintf('-f%s', $this->Sender);\n            }\n        }\n        if (!empty($this->Sender) and !ini_get('safe_mode') and $this->validateAddress($this->Sender)) {\n            $old_from = ini_get('sendmail_from');\n            ini_set('sendmail_from', $this->Sender);\n        }\n        $result = false;\n        if ($this->SingleTo and count($toArr) > 1) {\n            foreach ($toArr as $toAddr) {\n                $result = $this->mailPassthru($toAddr, $this->Subject, $body, $header, $params);\n                $this->doCallback($result, array($toAddr), $this->cc, $this->bcc, $this->Subject, $body, $this->From);\n            }\n        } else {\n            $result = $this->mailPassthru($to, $this->Subject, $body, $header, $params);\n            $this->doCallback($result, $this->to, $this->cc, $this->bcc, $this->Subject, $body, $this->From);\n        }\n        if (isset($old_from)) {\n            ini_set('sendmail_from', $old_from);\n        }\n        if (!$result) {\n            throw new phpmailerException($this->lang('instantiate'), self::STOP_CRITICAL);\n        }\n        return true;\n    }\n\n    /**\n     * Get an instance to use for SMTP operations.\n     * Override this function to load your own SMTP implementation\n     * @return SMTP\n     */\n    public function getSMTPInstance()\n    {\n        if (!is_object($this->smtp)) {\n            $this->smtp = new SMTP;\n        }\n        return $this->smtp;\n    }\n\n    /**\n     * Send mail via SMTP.\n     * Returns false if there is a bad MAIL FROM, RCPT, or DATA input.\n     * Uses the PHPMailerSMTP class by default.\n     * @see PHPMailer::getSMTPInstance() to use a different class.\n     * @param string $header The message headers\n     * @param string $body The message body\n     * @throws phpmailerException\n     * @uses SMTP\n     * @access protected\n     * @return boolean\n     */\n    protected function smtpSend($header, $body)\n    {\n        $bad_rcpt = array();\n        if (!$this->smtpConnect($this->SMTPOptions)) {\n            throw new phpmailerException($this->lang('smtp_connect_failed'), self::STOP_CRITICAL);\n        }\n        if (!empty($this->Sender) and $this->validateAddress($this->Sender)) {\n            $smtp_from = $this->Sender;\n        } else {\n            $smtp_from = $this->From;\n        }\n        if (!$this->smtp->mail($smtp_from)) {\n            $this->setError($this->lang('from_failed') . $smtp_from . ' : ' . implode(',', $this->smtp->getError()));\n            throw new phpmailerException($this->ErrorInfo, self::STOP_CRITICAL);\n        }\n\n        // Attempt to send to all recipients\n        foreach (array($this->to, $this->cc, $this->bcc) as $togroup) {\n            foreach ($togroup as $to) {\n                if (!$this->smtp->recipient($to[0])) {\n                    $error = $this->smtp->getError();\n                    $bad_rcpt[] = array('to' => $to[0], 'error' => $error['detail']);\n                    $isSent = false;\n                } else {\n                    $isSent = true;\n                }\n                $this->doCallback($isSent, array($to[0]), array(), array(), $this->Subject, $body, $this->From);\n            }\n        }\n\n        // Only send the DATA command if we have viable recipients\n        if ((count($this->all_recipients) > count($bad_rcpt)) and !$this->smtp->data($header . $body)) {\n            throw new phpmailerException($this->lang('data_not_accepted'), self::STOP_CRITICAL);\n        }\n        if ($this->SMTPKeepAlive) {\n            $this->smtp->reset();\n        } else {\n            $this->smtp->quit();\n            $this->smtp->close();\n        }\n        //Create error message for any bad addresses\n        if (count($bad_rcpt) > 0) {\n            $errstr = '';\n            foreach ($bad_rcpt as $bad) {\n                $errstr .= $bad['to'] . ': ' . $bad['error'];\n            }\n            throw new phpmailerException(\n                $this->lang('recipients_failed') . $errstr,\n                self::STOP_CONTINUE\n            );\n        }\n        return true;\n    }\n\n    /**\n     * Initiate a connection to an SMTP server.\n     * Returns false if the operation failed.\n     * @param array $options An array of options compatible with stream_context_create()\n     * @uses SMTP\n     * @access public\n     * @throws phpmailerException\n     * @return boolean\n     */\n    public function smtpConnect($options = null)\n    {\n        if (is_null($this->smtp)) {\n            $this->smtp = $this->getSMTPInstance();\n        }\n\n        //If no options are provided, use whatever is set in the instance\n        if (is_null($options)) {\n            $options = $this->SMTPOptions;\n        }\n\n        // Already connected?\n        if ($this->smtp->connected()) {\n            return true;\n        }\n\n        $this->smtp->setTimeout($this->Timeout);\n        $this->smtp->setDebugLevel($this->SMTPDebug);\n        $this->smtp->setDebugOutput($this->Debugoutput);\n        $this->smtp->setVerp($this->do_verp);\n        $hosts = explode(';', $this->Host);\n        $lastexception = null;\n\n        foreach ($hosts as $hostentry) {\n            $hostinfo = array();\n            if (!preg_match(\n                '/^((ssl|tls):\\/\\/)*([a-zA-Z0-9\\.-]*|\\[[a-fA-F0-9:]+\\]):?([0-9]*)$/',\n                trim($hostentry),\n                $hostinfo\n            )) {\n                // Not a valid host entry\n                $this->edebug('Ignoring invalid host: ' . $hostentry);\n                continue;\n            }\n            // $hostinfo[2]: optional ssl or tls prefix\n            // $hostinfo[3]: the hostname\n            // $hostinfo[4]: optional port number\n            // The host string prefix can temporarily override the current setting for SMTPSecure\n            // If it's not specified, the default value is used\n            $prefix = '';\n            $secure = $this->SMTPSecure;\n            $tls = ($this->SMTPSecure == 'tls');\n            if ('ssl' == $hostinfo[2] or ('' == $hostinfo[2] and 'ssl' == $this->SMTPSecure)) {\n                $prefix = 'ssl://';\n                $tls = false; // Can't have SSL and TLS at the same time\n                $secure = 'ssl';\n            } elseif ($hostinfo[2] == 'tls') {\n                $tls = true;\n                // tls doesn't use a prefix\n                $secure = 'tls';\n            }\n            //Do we need the OpenSSL extension?\n            $sslext = defined('OPENSSL_ALGO_SHA1');\n            if ('tls' === $secure or 'ssl' === $secure) {\n                //Check for an OpenSSL constant rather than using extension_loaded, which is sometimes disabled\n                if (!$sslext) {\n                    throw new phpmailerException($this->lang('extension_missing').'openssl', self::STOP_CRITICAL);\n                }\n            }\n            $host = $hostinfo[3];\n            $port = $this->Port;\n            $tport = (integer)$hostinfo[4];\n            if ($tport > 0 and $tport < 65536) {\n                $port = $tport;\n            }\n            if ($this->smtp->connect($prefix . $host, $port, $this->Timeout, $options)) {\n                try {\n                    if ($this->Helo) {\n                        $hello = $this->Helo;\n                    } else {\n                        $hello = $this->serverHostname();\n                    }\n                    $this->smtp->hello($hello);\n                    //Automatically enable TLS encryption if:\n                    // * it's not disabled\n                    // * we have openssl extension\n                    // * we are not already using SSL\n                    // * the server offers STARTTLS\n                    if ($this->SMTPAutoTLS and $sslext and $secure != 'ssl' and $this->smtp->getServerExt('STARTTLS')) {\n                        $tls = true;\n                    }\n                    if ($tls) {\n                        if (!$this->smtp->startTLS()) {\n                            throw new phpmailerException($this->lang('connect_host'));\n                        }\n                        // We must resend EHLO after TLS negotiation\n                        $this->smtp->hello($hello);\n                    }\n                    if ($this->SMTPAuth) {\n                        if (!$this->smtp->authenticate(\n                            $this->Username,\n                            $this->Password,\n                            $this->AuthType,\n                            $this->Realm,\n                            $this->Workstation\n                        )\n                        ) {\n                            throw new phpmailerException($this->lang('authenticate'));\n                        }\n                    }\n                    return true;\n                } catch (phpmailerException $exc) {\n                    $lastexception = $exc;\n                    $this->edebug($exc->getMessage());\n                    // We must have connected, but then failed TLS or Auth, so close connection nicely\n                    $this->smtp->quit();\n                }\n            }\n        }\n        // If we get here, all connection attempts have failed, so close connection hard\n        $this->smtp->close();\n        // As we've caught all exceptions, just report whatever the last one was\n        if ($this->exceptions and !is_null($lastexception)) {\n            throw $lastexception;\n        }\n        return false;\n    }\n\n    /**\n     * Close the active SMTP session if one exists.\n     * @return void\n     */\n    public function smtpClose()\n    {\n        if (is_a($this->smtp, 'SMTP')) {\n            if ($this->smtp->connected()) {\n                $this->smtp->quit();\n                $this->smtp->close();\n            }\n        }\n    }\n\n    /**\n     * Set the language for error messages.\n     * Returns false if it cannot load the language file.\n     * The default language is English.\n     * @param string $langcode ISO 639-1 2-character language code (e.g. French is \"fr\")\n     * @param string $lang_path Path to the language file directory, with trailing separator (slash)\n     * @return boolean\n     * @access public\n     */\n    public function setLanguage($langcode = 'en', $lang_path = '')\n    {\n        // Backwards compatibility for renamed language codes\n        $renamed_langcodes = array(\n            'br' => 'pt_br',\n            'cz' => 'cs',\n            'dk' => 'da',\n            'no' => 'nb',\n            'se' => 'sv',\n            'sr' => 'rs'\n        );\n\n        if (isset($renamed_langcodes[$langcode])) {\n            $langcode = $renamed_langcodes[$langcode];\n        }\n\n        // Define full set of translatable strings in English\n        $PHPMAILER_LANG = array(\n            'authenticate' => 'SMTP Error: Could not authenticate.',\n            'connect_host' => 'SMTP Error: Could not connect to SMTP host.',\n            'data_not_accepted' => 'SMTP Error: data not accepted.',\n            'empty_message' => 'Message body empty',\n            'encoding' => 'Unknown encoding: ',\n            'execute' => 'Could not execute: ',\n            'file_access' => 'Could not access file: ',\n            'file_open' => 'File Error: Could not open file: ',\n            'from_failed' => 'The following From address failed: ',\n            'instantiate' => 'Could not instantiate mail function.',\n            'invalid_address' => 'Invalid address: ',\n            'mailer_not_supported' => ' mailer is not supported.',\n            'provide_address' => 'You must provide at least one recipient email address.',\n            'recipients_failed' => 'SMTP Error: The following recipients failed: ',\n            'signing' => 'Signing Error: ',\n            'smtp_connect_failed' => 'SMTP connect() failed.',\n            'smtp_error' => 'SMTP server error: ',\n            'variable_set' => 'Cannot set or reset variable: ',\n            'extension_missing' => 'Extension missing: '\n        );\n        if (empty($lang_path)) {\n            // Calculate an absolute path so it can work if CWD is not here\n            $lang_path = dirname(__FILE__). DIRECTORY_SEPARATOR . 'language'. DIRECTORY_SEPARATOR;\n        }\n        //Validate $langcode\n        if (!preg_match('/^[a-z]{2}(?:_[a-zA-Z]{2})?$/', $langcode)) {\n            $langcode = 'en';\n        }\n        $foundlang = true;\n        $lang_file = $lang_path . 'phpmailer.lang-' . $langcode . '.php';\n        // There is no English translation file\n        if ($langcode != 'en') {\n            // Make sure language file path is readable\n            if (!self::isPermittedPath($lang_file) or !is_readable($lang_file)) {\n                $foundlang = false;\n            } else {\n                // Overwrite language-specific strings.\n                // This way we'll never have missing translation keys.\n                $foundlang = include $lang_file;\n            }\n        }\n        $this->language = $PHPMAILER_LANG;\n        return (boolean)$foundlang; // Returns false if language not found\n    }\n\n    /**\n     * Get the array of strings for the current language.\n     * @return array\n     */\n    public function getTranslations()\n    {\n        return $this->language;\n    }\n\n    /**\n     * Create recipient headers.\n     * @access public\n     * @param string $type\n     * @param array $addr An array of recipient,\n     * where each recipient is a 2-element indexed array with element 0 containing an address\n     * and element 1 containing a name, like:\n     * array(array('joe@example.com', 'Joe User'), array('zoe@example.com', 'Zoe User'))\n     * @return string\n     */\n    public function addrAppend($type, $addr)\n    {\n        $addresses = array();\n        foreach ($addr as $address) {\n            $addresses[] = $this->addrFormat($address);\n        }\n        return $type . ': ' . implode(', ', $addresses) . $this->LE;\n    }\n\n    /**\n     * Format an address for use in a message header.\n     * @access public\n     * @param array $addr A 2-element indexed array, element 0 containing an address, element 1 containing a name\n     *      like array('joe@example.com', 'Joe User')\n     * @return string\n     */\n    public function addrFormat($addr)\n    {\n        if (empty($addr[1])) { // No name provided\n            return $this->secureHeader($addr[0]);\n        } else {\n            return $this->encodeHeader($this->secureHeader($addr[1]), 'phrase') . ' <' . $this->secureHeader(\n                $addr[0]\n            ) . '>';\n        }\n    }\n\n    /**\n     * Word-wrap message.\n     * For use with mailers that do not automatically perform wrapping\n     * and for quoted-printable encoded messages.\n     * Original written by philippe.\n     * @param string $message The message to wrap\n     * @param integer $length The line length to wrap to\n     * @param boolean $qp_mode Whether to run in Quoted-Printable mode\n     * @access public\n     * @return string\n     */\n    public function wrapText($message, $length, $qp_mode = false)\n    {\n        if ($qp_mode) {\n            $soft_break = sprintf(' =%s', $this->LE);\n        } else {\n            $soft_break = $this->LE;\n        }\n        // If utf-8 encoding is used, we will need to make sure we don't\n        // split multibyte characters when we wrap\n        $is_utf8 = (strtolower($this->CharSet) == 'utf-8');\n        $lelen = strlen($this->LE);\n        $crlflen = strlen(self::CRLF);\n\n        $message = $this->fixEOL($message);\n        //Remove a trailing line break\n        if (substr($message, -$lelen) == $this->LE) {\n            $message = substr($message, 0, -$lelen);\n        }\n\n        //Split message into lines\n        $lines = explode($this->LE, $message);\n        //Message will be rebuilt in here\n        $message = '';\n        foreach ($lines as $line) {\n            $words = explode(' ', $line);\n            $buf = '';\n            $firstword = true;\n            foreach ($words as $word) {\n                if ($qp_mode and (strlen($word) > $length)) {\n                    $space_left = $length - strlen($buf) - $crlflen;\n                    if (!$firstword) {\n                        if ($space_left > 20) {\n                            $len = $space_left;\n                            if ($is_utf8) {\n                                $len = $this->utf8CharBoundary($word, $len);\n                            } elseif (substr($word, $len - 1, 1) == '=') {\n                                $len--;\n                            } elseif (substr($word, $len - 2, 1) == '=') {\n                                $len -= 2;\n                            }\n                            $part = substr($word, 0, $len);\n                            $word = substr($word, $len);\n                            $buf .= ' ' . $part;\n                            $message .= $buf . sprintf('=%s', self::CRLF);\n                        } else {\n                            $message .= $buf . $soft_break;\n                        }\n                        $buf = '';\n                    }\n                    while (strlen($word) > 0) {\n                        if ($length <= 0) {\n                            break;\n                        }\n                        $len = $length;\n                        if ($is_utf8) {\n                            $len = $this->utf8CharBoundary($word, $len);\n                        } elseif (substr($word, $len - 1, 1) == '=') {\n                            $len--;\n                        } elseif (substr($word, $len - 2, 1) == '=') {\n                            $len -= 2;\n                        }\n                        $part = substr($word, 0, $len);\n                        $word = substr($word, $len);\n\n                        if (strlen($word) > 0) {\n                            $message .= $part . sprintf('=%s', self::CRLF);\n                        } else {\n                            $buf = $part;\n                        }\n                    }\n                } else {\n                    $buf_o = $buf;\n                    if (!$firstword) {\n                        $buf .= ' ';\n                    }\n                    $buf .= $word;\n\n                    if (strlen($buf) > $length and $buf_o != '') {\n                        $message .= $buf_o . $soft_break;\n                        $buf = $word;\n                    }\n                }\n                $firstword = false;\n            }\n            $message .= $buf . self::CRLF;\n        }\n\n        return $message;\n    }\n\n    /**\n     * Find the last character boundary prior to $maxLength in a utf-8\n     * quoted-printable encoded string.\n     * Original written by Colin Brown.\n     * @access public\n     * @param string $encodedText utf-8 QP text\n     * @param integer $maxLength Find the last character boundary prior to this length\n     * @return integer\n     */\n    public function utf8CharBoundary($encodedText, $maxLength)\n    {\n        $foundSplitPos = false;\n        $lookBack = 3;\n        while (!$foundSplitPos) {\n            $lastChunk = substr($encodedText, $maxLength - $lookBack, $lookBack);\n            $encodedCharPos = strpos($lastChunk, '=');\n            if (false !== $encodedCharPos) {\n                // Found start of encoded character byte within $lookBack block.\n                // Check the encoded byte value (the 2 chars after the '=')\n                $hex = substr($encodedText, $maxLength - $lookBack + $encodedCharPos + 1, 2);\n                $dec = hexdec($hex);\n                if ($dec < 128) {\n                    // Single byte character.\n                    // If the encoded char was found at pos 0, it will fit\n                    // otherwise reduce maxLength to start of the encoded char\n                    if ($encodedCharPos > 0) {\n                        $maxLength = $maxLength - ($lookBack - $encodedCharPos);\n                    }\n                    $foundSplitPos = true;\n                } elseif ($dec >= 192) {\n                    // First byte of a multi byte character\n                    // Reduce maxLength to split at start of character\n                    $maxLength = $maxLength - ($lookBack - $encodedCharPos);\n                    $foundSplitPos = true;\n                } elseif ($dec < 192) {\n                    // Middle byte of a multi byte character, look further back\n                    $lookBack += 3;\n                }\n            } else {\n                // No encoded character found\n                $foundSplitPos = true;\n            }\n        }\n        return $maxLength;\n    }\n\n    /**\n     * Apply word wrapping to the message body.\n     * Wraps the message body to the number of chars set in the WordWrap property.\n     * You should only do this to plain-text bodies as wrapping HTML tags may break them.\n     * This is called automatically by createBody(), so you don't need to call it yourself.\n     * @access public\n     * @return void\n     */\n    public function setWordWrap()\n    {\n        if ($this->WordWrap < 1) {\n            return;\n        }\n\n        switch ($this->message_type) {\n            case 'alt':\n            case 'alt_inline':\n            case 'alt_attach':\n            case 'alt_inline_attach':\n                $this->AltBody = $this->wrapText($this->AltBody, $this->WordWrap);\n                break;\n            default:\n                $this->Body = $this->wrapText($this->Body, $this->WordWrap);\n                break;\n        }\n    }\n\n    /**\n     * Assemble message headers.\n     * @access public\n     * @return string The assembled headers\n     */\n    public function createHeader()\n    {\n        $result = '';\n\n        $result .= $this->headerLine('Date', $this->MessageDate == '' ? self::rfcDate() : $this->MessageDate);\n\n        // To be created automatically by mail()\n        if ($this->SingleTo) {\n            if ($this->Mailer != 'mail') {\n                foreach ($this->to as $toaddr) {\n                    $this->SingleToArray[] = $this->addrFormat($toaddr);\n                }\n            }\n        } else {\n            if (count($this->to) > 0) {\n                if ($this->Mailer != 'mail') {\n                    $result .= $this->addrAppend('To', $this->to);\n                }\n            } elseif (count($this->cc) == 0) {\n                $result .= $this->headerLine('To', 'undisclosed-recipients:;');\n            }\n        }\n\n        $result .= $this->addrAppend('From', array(array(trim($this->From), $this->FromName)));\n\n        // sendmail and mail() extract Cc from the header before sending\n        if (count($this->cc) > 0) {\n            $result .= $this->addrAppend('Cc', $this->cc);\n        }\n\n        // sendmail and mail() extract Bcc from the header before sending\n        if ((\n                $this->Mailer == 'sendmail' or $this->Mailer == 'qmail' or $this->Mailer == 'mail'\n            )\n            and count($this->bcc) > 0\n        ) {\n            $result .= $this->addrAppend('Bcc', $this->bcc);\n        }\n\n        if (count($this->ReplyTo) > 0) {\n            $result .= $this->addrAppend('Reply-To', $this->ReplyTo);\n        }\n\n        // mail() sets the subject itself\n        if ($this->Mailer != 'mail') {\n            $result .= $this->headerLine('Subject', $this->encodeHeader($this->secureHeader($this->Subject)));\n        }\n\n        // Only allow a custom message ID if it conforms to RFC 5322 section 3.6.4\n        // https://tools.ietf.org/html/rfc5322#section-3.6.4\n        if ('' != $this->MessageID and preg_match('/^<.*@.*>$/', $this->MessageID)) {\n            $this->lastMessageID = $this->MessageID;\n        } else {\n            $this->lastMessageID = sprintf('<%s@%s>', $this->uniqueid, $this->serverHostname());\n        }\n        $result .= $this->headerLine('Message-ID', $this->lastMessageID);\n        if (!is_null($this->Priority)) {\n            $result .= $this->headerLine('X-Priority', $this->Priority);\n        }\n        if ($this->XMailer == '') {\n            $result .= $this->headerLine(\n                'X-Mailer',\n                'PHPMailer ' . $this->Version . ' (https://github.com/PHPMailer/PHPMailer)'\n            );\n        } else {\n            $myXmailer = trim($this->XMailer);\n            if ($myXmailer) {\n                $result .= $this->headerLine('X-Mailer', $myXmailer);\n            }\n        }\n\n        if ($this->ConfirmReadingTo != '') {\n            $result .= $this->headerLine('Disposition-Notification-To', '<' . $this->ConfirmReadingTo . '>');\n        }\n\n        // Add custom headers\n        foreach ($this->CustomHeader as $header) {\n            $result .= $this->headerLine(\n                trim($header[0]),\n                $this->encodeHeader(trim($header[1]))\n            );\n        }\n        if (!$this->sign_key_file) {\n            $result .= $this->headerLine('MIME-Version', '1.0');\n            $result .= $this->getMailMIME();\n        }\n\n        return $result;\n    }\n\n    /**\n     * Get the message MIME type headers.\n     * @access public\n     * @return string\n     */\n    public function getMailMIME()\n    {\n        $result = '';\n        $ismultipart = true;\n        switch ($this->message_type) {\n            case 'inline':\n                $result .= $this->headerLine('Content-Type', 'multipart/related;');\n                $result .= $this->textLine(\"\\tboundary=\\\"\" . $this->boundary[1] . '\"');\n                break;\n            case 'attach':\n            case 'inline_attach':\n            case 'alt_attach':\n            case 'alt_inline_attach':\n                $result .= $this->headerLine('Content-Type', 'multipart/mixed;');\n                $result .= $this->textLine(\"\\tboundary=\\\"\" . $this->boundary[1] . '\"');\n                break;\n            case 'alt':\n            case 'alt_inline':\n                $result .= $this->headerLine('Content-Type', 'multipart/alternative;');\n                $result .= $this->textLine(\"\\tboundary=\\\"\" . $this->boundary[1] . '\"');\n                break;\n            default:\n                // Catches case 'plain': and case '':\n                $result .= $this->textLine('Content-Type: ' . $this->ContentType . '; charset=' . $this->CharSet);\n                $ismultipart = false;\n                break;\n        }\n        // RFC1341 part 5 says 7bit is assumed if not specified\n        if ($this->Encoding != '7bit') {\n            // RFC 2045 section 6.4 says multipart MIME parts may only use 7bit, 8bit or binary CTE\n            if ($ismultipart) {\n                if ($this->Encoding == '8bit') {\n                    $result .= $this->headerLine('Content-Transfer-Encoding', '8bit');\n                }\n                // The only remaining alternatives are quoted-printable and base64, which are both 7bit compatible\n            } else {\n                $result .= $this->headerLine('Content-Transfer-Encoding', $this->Encoding);\n            }\n        }\n\n        if ($this->Mailer != 'mail') {\n            $result .= $this->LE;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Returns the whole MIME message.\n     * Includes complete headers and body.\n     * Only valid post preSend().\n     * @see PHPMailer::preSend()\n     * @access public\n     * @return string\n     */\n    public function getSentMIMEMessage()\n    {\n        return rtrim($this->MIMEHeader . $this->mailHeader, \"\\n\\r\") . self::CRLF . self::CRLF . $this->MIMEBody;\n    }\n\n    /**\n     * Create unique ID\n     * @return string\n     */\n    protected function generateId() {\n        return md5(uniqid(time()));\n    }\n\n    /**\n     * Assemble the message body.\n     * Returns an empty string on failure.\n     * @access public\n     * @throws phpmailerException\n     * @return string The assembled message body\n     */\n    public function createBody()\n    {\n        $body = '';\n        //Create unique IDs and preset boundaries\n        $this->uniqueid = $this->generateId();\n        $this->boundary[1] = 'b1_' . $this->uniqueid;\n        $this->boundary[2] = 'b2_' . $this->uniqueid;\n        $this->boundary[3] = 'b3_' . $this->uniqueid;\n\n        if ($this->sign_key_file) {\n            $body .= $this->getMailMIME() . $this->LE;\n        }\n\n        $this->setWordWrap();\n\n        $bodyEncoding = $this->Encoding;\n        $bodyCharSet = $this->CharSet;\n        //Can we do a 7-bit downgrade?\n        if ($bodyEncoding == '8bit' and !$this->has8bitChars($this->Body)) {\n            $bodyEncoding = '7bit';\n            //All ISO 8859, Windows codepage and UTF-8 charsets are ascii compatible up to 7-bit\n            $bodyCharSet = 'us-ascii';\n        }\n        //If lines are too long, and we're not already using an encoding that will shorten them,\n        //change to quoted-printable transfer encoding for the body part only\n        if ('base64' != $this->Encoding and self::hasLineLongerThanMax($this->Body)) {\n            $bodyEncoding = 'quoted-printable';\n        }\n\n        $altBodyEncoding = $this->Encoding;\n        $altBodyCharSet = $this->CharSet;\n        //Can we do a 7-bit downgrade?\n        if ($altBodyEncoding == '8bit' and !$this->has8bitChars($this->AltBody)) {\n            $altBodyEncoding = '7bit';\n            //All ISO 8859, Windows codepage and UTF-8 charsets are ascii compatible up to 7-bit\n            $altBodyCharSet = 'us-ascii';\n        }\n        //If lines are too long, and we're not already using an encoding that will shorten them,\n        //change to quoted-printable transfer encoding for the alt body part only\n        if ('base64' != $altBodyEncoding and self::hasLineLongerThanMax($this->AltBody)) {\n            $altBodyEncoding = 'quoted-printable';\n        }\n        //Use this as a preamble in all multipart message types\n        $mimepre = \"This is a multi-part message in MIME format.\" . $this->LE . $this->LE;\n        switch ($this->message_type) {\n            case 'inline':\n                $body .= $mimepre;\n                $body .= $this->getBoundary($this->boundary[1], $bodyCharSet, '', $bodyEncoding);\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= $this->LE . $this->LE;\n                $body .= $this->attachAll('inline', $this->boundary[1]);\n                break;\n            case 'attach':\n                $body .= $mimepre;\n                $body .= $this->getBoundary($this->boundary[1], $bodyCharSet, '', $bodyEncoding);\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= $this->LE . $this->LE;\n                $body .= $this->attachAll('attachment', $this->boundary[1]);\n                break;\n            case 'inline_attach':\n                $body .= $mimepre;\n                $body .= $this->textLine('--' . $this->boundary[1]);\n                $body .= $this->headerLine('Content-Type', 'multipart/related;');\n                $body .= $this->textLine(\"\\tboundary=\\\"\" . $this->boundary[2] . '\"');\n                $body .= $this->LE;\n                $body .= $this->getBoundary($this->boundary[2], $bodyCharSet, '', $bodyEncoding);\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= $this->LE . $this->LE;\n                $body .= $this->attachAll('inline', $this->boundary[2]);\n                $body .= $this->LE;\n                $body .= $this->attachAll('attachment', $this->boundary[1]);\n                break;\n            case 'alt':\n                $body .= $mimepre;\n                $body .= $this->getBoundary($this->boundary[1], $altBodyCharSet, 'text/plain', $altBodyEncoding);\n                $body .= $this->encodeString($this->AltBody, $altBodyEncoding);\n                $body .= $this->LE . $this->LE;\n                $body .= $this->getBoundary($this->boundary[1], $bodyCharSet, 'text/html', $bodyEncoding);\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= $this->LE . $this->LE;\n                if (!empty($this->Ical)) {\n                    $body .= $this->getBoundary($this->boundary[1], '', 'text/calendar; method=REQUEST', '');\n                    $body .= $this->encodeString($this->Ical, $this->Encoding);\n                    $body .= $this->LE . $this->LE;\n                }\n                $body .= $this->endBoundary($this->boundary[1]);\n                break;\n            case 'alt_inline':\n                $body .= $mimepre;\n                $body .= $this->getBoundary($this->boundary[1], $altBodyCharSet, 'text/plain', $altBodyEncoding);\n                $body .= $this->encodeString($this->AltBody, $altBodyEncoding);\n                $body .= $this->LE . $this->LE;\n                $body .= $this->textLine('--' . $this->boundary[1]);\n                $body .= $this->headerLine('Content-Type', 'multipart/related;');\n                $body .= $this->textLine(\"\\tboundary=\\\"\" . $this->boundary[2] . '\"');\n                $body .= $this->LE;\n                $body .= $this->getBoundary($this->boundary[2], $bodyCharSet, 'text/html', $bodyEncoding);\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= $this->LE . $this->LE;\n                $body .= $this->attachAll('inline', $this->boundary[2]);\n                $body .= $this->LE;\n                $body .= $this->endBoundary($this->boundary[1]);\n                break;\n            case 'alt_attach':\n                $body .= $mimepre;\n                $body .= $this->textLine('--' . $this->boundary[1]);\n                $body .= $this->headerLine('Content-Type', 'multipart/alternative;');\n                $body .= $this->textLine(\"\\tboundary=\\\"\" . $this->boundary[2] . '\"');\n                $body .= $this->LE;\n                $body .= $this->getBoundary($this->boundary[2], $altBodyCharSet, 'text/plain', $altBodyEncoding);\n                $body .= $this->encodeString($this->AltBody, $altBodyEncoding);\n                $body .= $this->LE . $this->LE;\n                $body .= $this->getBoundary($this->boundary[2], $bodyCharSet, 'text/html', $bodyEncoding);\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= $this->LE . $this->LE;\n                $body .= $this->endBoundary($this->boundary[2]);\n                $body .= $this->LE;\n                $body .= $this->attachAll('attachment', $this->boundary[1]);\n                break;\n            case 'alt_inline_attach':\n                $body .= $mimepre;\n                $body .= $this->textLine('--' . $this->boundary[1]);\n                $body .= $this->headerLine('Content-Type', 'multipart/alternative;');\n                $body .= $this->textLine(\"\\tboundary=\\\"\" . $this->boundary[2] . '\"');\n                $body .= $this->LE;\n                $body .= $this->getBoundary($this->boundary[2], $altBodyCharSet, 'text/plain', $altBodyEncoding);\n                $body .= $this->encodeString($this->AltBody, $altBodyEncoding);\n                $body .= $this->LE . $this->LE;\n                $body .= $this->textLine('--' . $this->boundary[2]);\n                $body .= $this->headerLine('Content-Type', 'multipart/related;');\n                $body .= $this->textLine(\"\\tboundary=\\\"\" . $this->boundary[3] . '\"');\n                $body .= $this->LE;\n                $body .= $this->getBoundary($this->boundary[3], $bodyCharSet, 'text/html', $bodyEncoding);\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= $this->LE . $this->LE;\n                $body .= $this->attachAll('inline', $this->boundary[3]);\n                $body .= $this->LE;\n                $body .= $this->endBoundary($this->boundary[2]);\n                $body .= $this->LE;\n                $body .= $this->attachAll('attachment', $this->boundary[1]);\n                break;\n            default:\n                // Catch case 'plain' and case '', applies to simple `text/plain` and `text/html` body content types\n                //Reset the `Encoding` property in case we changed it for line length reasons\n                $this->Encoding = $bodyEncoding;\n                $body .= $this->encodeString($this->Body, $this->Encoding);\n                break;\n        }\n\n        if ($this->isError()) {\n            $body = '';\n        } elseif ($this->sign_key_file) {\n            try {\n                if (!defined('PKCS7_TEXT')) {\n                    throw new phpmailerException($this->lang('extension_missing') . 'openssl');\n                }\n                // @TODO would be nice to use php://temp streams here, but need to wrap for PHP < 5.1\n                $file = tempnam(sys_get_temp_dir(), 'mail');\n                if (false === file_put_contents($file, $body)) {\n                    throw new phpmailerException($this->lang('signing') . ' Could not write temp file');\n                }\n                $signed = tempnam(sys_get_temp_dir(), 'signed');\n                //Workaround for PHP bug https://bugs.php.net/bug.php?id=69197\n                if (empty($this->sign_extracerts_file)) {\n                    $sign = @openssl_pkcs7_sign(\n                        $file,\n                        $signed,\n                        'file://' . realpath($this->sign_cert_file),\n                        array('file://' . realpath($this->sign_key_file), $this->sign_key_pass),\n                        null\n                    );\n                } else {\n                    $sign = @openssl_pkcs7_sign(\n                        $file,\n                        $signed,\n                        'file://' . realpath($this->sign_cert_file),\n                        array('file://' . realpath($this->sign_key_file), $this->sign_key_pass),\n                        null,\n                        PKCS7_DETACHED,\n                        $this->sign_extracerts_file\n                    );\n                }\n                if ($sign) {\n                    @unlink($file);\n                    $body = file_get_contents($signed);\n                    @unlink($signed);\n                    //The message returned by openssl contains both headers and body, so need to split them up\n                    $parts = explode(\"\\n\\n\", $body, 2);\n                    $this->MIMEHeader .= $parts[0] . $this->LE . $this->LE;\n                    $body = $parts[1];\n                } else {\n                    @unlink($file);\n                    @unlink($signed);\n                    throw new phpmailerException($this->lang('signing') . openssl_error_string());\n                }\n            } catch (phpmailerException $exc) {\n                $body = '';\n                if ($this->exceptions) {\n                    throw $exc;\n                }\n            }\n        }\n        return $body;\n    }\n\n    /**\n     * Return the start of a message boundary.\n     * @access protected\n     * @param string $boundary\n     * @param string $charSet\n     * @param string $contentType\n     * @param string $encoding\n     * @return string\n     */\n    protected function getBoundary($boundary, $charSet, $contentType, $encoding)\n    {\n        $result = '';\n        if ($charSet == '') {\n            $charSet = $this->CharSet;\n        }\n        if ($contentType == '') {\n            $contentType = $this->ContentType;\n        }\n        if ($encoding == '') {\n            $encoding = $this->Encoding;\n        }\n        $result .= $this->textLine('--' . $boundary);\n        $result .= sprintf('Content-Type: %s; charset=%s', $contentType, $charSet);\n        $result .= $this->LE;\n        // RFC1341 part 5 says 7bit is assumed if not specified\n        if ($encoding != '7bit') {\n            $result .= $this->headerLine('Content-Transfer-Encoding', $encoding);\n        }\n        $result .= $this->LE;\n\n        return $result;\n    }\n\n    /**\n     * Return the end of a message boundary.\n     * @access protected\n     * @param string $boundary\n     * @return string\n     */\n    protected function endBoundary($boundary)\n    {\n        return $this->LE . '--' . $boundary . '--' . $this->LE;\n    }\n\n    /**\n     * Set the message type.\n     * PHPMailer only supports some preset message types, not arbitrary MIME structures.\n     * @access protected\n     * @return void\n     */\n    protected function setMessageType()\n    {\n        $type = array();\n        if ($this->alternativeExists()) {\n            $type[] = 'alt';\n        }\n        if ($this->inlineImageExists()) {\n            $type[] = 'inline';\n        }\n        if ($this->attachmentExists()) {\n            $type[] = 'attach';\n        }\n        $this->message_type = implode('_', $type);\n        if ($this->message_type == '') {\n            //The 'plain' message_type refers to the message having a single body element, not that it is plain-text\n            $this->message_type = 'plain';\n        }\n    }\n\n    /**\n     * Format a header line.\n     * @access public\n     * @param string $name\n     * @param string $value\n     * @return string\n     */\n    public function headerLine($name, $value)\n    {\n        return $name . ': ' . $value . $this->LE;\n    }\n\n    /**\n     * Return a formatted mail line.\n     * @access public\n     * @param string $value\n     * @return string\n     */\n    public function textLine($value)\n    {\n        return $value . $this->LE;\n    }\n\n    /**\n     * Add an attachment from a path on the filesystem.\n     * Never use a user-supplied path to a file!\n     * Returns false if the file could not be found or read.\n     * Explicitly *does not* support passing URLs; PHPMailer is not an HTTP client.\n     * If you need to do that, fetch the resource yourself and pass it in via a local file or string.\n     * @param string $path Path to the attachment.\n     * @param string $name Overrides the attachment name.\n     * @param string $encoding File encoding (see $Encoding).\n     * @param string $type File extension (MIME) type.\n     * @param string $disposition Disposition to use\n     * @throws phpmailerException\n     * @return boolean\n     */\n    public function addAttachment($path, $name = '', $encoding = 'base64', $type = '', $disposition = 'attachment')\n    {\n        try {\n            if (!self::isPermittedPath($path) or !@is_file($path)) {\n                throw new phpmailerException($this->lang('file_access') . $path, self::STOP_CONTINUE);\n            }\n\n            // If a MIME type is not specified, try to work it out from the file name\n            if ($type == '') {\n                $type = self::filenameToType($path);\n            }\n\n            $filename = basename($path);\n            if ($name == '') {\n                $name = $filename;\n            }\n\n            $this->attachment[] = array(\n                0 => $path,\n                1 => $filename,\n                2 => $name,\n                3 => $encoding,\n                4 => $type,\n                5 => false, // isStringAttachment\n                6 => $disposition,\n                7 => 0\n            );\n\n        } catch (phpmailerException $exc) {\n            $this->setError($exc->getMessage());\n            $this->edebug($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Return the array of attachments.\n     * @return array\n     */\n    public function getAttachments()\n    {\n        return $this->attachment;\n    }\n\n    /**\n     * Attach all file, string, and binary attachments to the message.\n     * Returns an empty string on failure.\n     * @access protected\n     * @param string $disposition_type\n     * @param string $boundary\n     * @return string\n     */\n    protected function attachAll($disposition_type, $boundary)\n    {\n        // Return text of body\n        $mime = array();\n        $cidUniq = array();\n        $incl = array();\n\n        // Add all attachments\n        foreach ($this->attachment as $attachment) {\n            // Check if it is a valid disposition_filter\n            if ($attachment[6] == $disposition_type) {\n                // Check for string attachment\n                $string = '';\n                $path = '';\n                $bString = $attachment[5];\n                if ($bString) {\n                    $string = $attachment[0];\n                } else {\n                    $path = $attachment[0];\n                }\n\n                $inclhash = md5(serialize($attachment));\n                if (in_array($inclhash, $incl)) {\n                    continue;\n                }\n                $incl[] = $inclhash;\n                $name = $attachment[2];\n                $encoding = $attachment[3];\n                $type = $attachment[4];\n                $disposition = $attachment[6];\n                $cid = $attachment[7];\n                if ($disposition == 'inline' && array_key_exists($cid, $cidUniq)) {\n                    continue;\n                }\n                $cidUniq[$cid] = true;\n\n                $mime[] = sprintf('--%s%s', $boundary, $this->LE);\n                //Only include a filename property if we have one\n                if (!empty($name)) {\n                    $mime[] = sprintf(\n                        'Content-Type: %s; name=\"%s\"%s',\n                        $type,\n                        $this->encodeHeader($this->secureHeader($name)),\n                        $this->LE\n                    );\n                } else {\n                    $mime[] = sprintf(\n                        'Content-Type: %s%s',\n                        $type,\n                        $this->LE\n                    );\n                }\n                // RFC1341 part 5 says 7bit is assumed if not specified\n                if ($encoding != '7bit') {\n                    $mime[] = sprintf('Content-Transfer-Encoding: %s%s', $encoding, $this->LE);\n                }\n\n                if ($disposition == 'inline') {\n                    $mime[] = sprintf('Content-ID: <%s>%s', $cid, $this->LE);\n                }\n\n                // If a filename contains any of these chars, it should be quoted,\n                // but not otherwise: RFC2183 & RFC2045 5.1\n                // Fixes a warning in IETF's msglint MIME checker\n                // Allow for bypassing the Content-Disposition header totally\n                if (!(empty($disposition))) {\n                    $encoded_name = $this->encodeHeader($this->secureHeader($name));\n                    if (preg_match('/[ \\(\\)<>@,;:\\\\\"\\/\\[\\]\\?=]/', $encoded_name)) {\n                        $mime[] = sprintf(\n                            'Content-Disposition: %s; filename=\"%s\"%s',\n                            $disposition,\n                            $encoded_name,\n                            $this->LE . $this->LE\n                        );\n                    } else {\n                        if (!empty($encoded_name)) {\n                            $mime[] = sprintf(\n                                'Content-Disposition: %s; filename=%s%s',\n                                $disposition,\n                                $encoded_name,\n                                $this->LE . $this->LE\n                            );\n                        } else {\n                            $mime[] = sprintf(\n                                'Content-Disposition: %s%s',\n                                $disposition,\n                                $this->LE . $this->LE\n                            );\n                        }\n                    }\n                } else {\n                    $mime[] = $this->LE;\n                }\n\n                // Encode as string attachment\n                if ($bString) {\n                    $mime[] = $this->encodeString($string, $encoding);\n                    if ($this->isError()) {\n                        return '';\n                    }\n                    $mime[] = $this->LE . $this->LE;\n                } else {\n                    $mime[] = $this->encodeFile($path, $encoding);\n                    if ($this->isError()) {\n                        return '';\n                    }\n                    $mime[] = $this->LE . $this->LE;\n                }\n            }\n        }\n\n        $mime[] = sprintf('--%s--%s', $boundary, $this->LE);\n\n        return implode('', $mime);\n    }\n\n    /**\n     * Encode a file attachment in requested format.\n     * Returns an empty string on failure.\n     * @param string $path The full path to the file\n     * @param string $encoding The encoding to use; one of 'base64', '7bit', '8bit', 'binary', 'quoted-printable'\n     * @throws phpmailerException\n     * @access protected\n     * @return string\n     */\n    protected function encodeFile($path, $encoding = 'base64')\n    {\n        try {\n            if (!self::isPermittedPath($path) or !file_exists($path)) {\n                throw new phpmailerException($this->lang('file_open') . $path, self::STOP_CONTINUE);\n            }\n            $magic_quotes = get_magic_quotes_runtime();\n            if ($magic_quotes) {\n                if (version_compare(PHP_VERSION, '5.3.0', '<')) {\n                    set_magic_quotes_runtime(false);\n                } else {\n                    //Doesn't exist in PHP 5.4, but we don't need to check because\n                    //get_magic_quotes_runtime always returns false in 5.4+\n                    //so it will never get here\n                    ini_set('magic_quotes_runtime', false);\n                }\n            }\n            $file_buffer = file_get_contents($path);\n            $file_buffer = $this->encodeString($file_buffer, $encoding);\n            if ($magic_quotes) {\n                if (version_compare(PHP_VERSION, '5.3.0', '<')) {\n                    set_magic_quotes_runtime($magic_quotes);\n                } else {\n                    ini_set('magic_quotes_runtime', $magic_quotes);\n                }\n            }\n            return $file_buffer;\n        } catch (Exception $exc) {\n            $this->setError($exc->getMessage());\n            return '';\n        }\n    }\n\n    /**\n     * Encode a string in requested format.\n     * Returns an empty string on failure.\n     * @param string $str The text to encode\n     * @param string $encoding The encoding to use; one of 'base64', '7bit', '8bit', 'binary', 'quoted-printable'\n     * @access public\n     * @return string\n     */\n    public function encodeString($str, $encoding = 'base64')\n    {\n        $encoded = '';\n        switch (strtolower($encoding)) {\n            case 'base64':\n                $encoded = chunk_split(base64_encode($str), 76, $this->LE);\n                break;\n            case '7bit':\n            case '8bit':\n                $encoded = $this->fixEOL($str);\n                // Make sure it ends with a line break\n                if (substr($encoded, -(strlen($this->LE))) != $this->LE) {\n                    $encoded .= $this->LE;\n                }\n                break;\n            case 'binary':\n                $encoded = $str;\n                break;\n            case 'quoted-printable':\n                $encoded = $this->encodeQP($str);\n                break;\n            default:\n                $this->setError($this->lang('encoding') . $encoding);\n                break;\n        }\n        return $encoded;\n    }\n\n    /**\n     * Encode a header string optimally.\n     * Picks shortest of Q, B, quoted-printable or none.\n     * @access public\n     * @param string $str\n     * @param string $position\n     * @return string\n     */\n    public function encodeHeader($str, $position = 'text')\n    {\n        $matchcount = 0;\n        switch (strtolower($position)) {\n            case 'phrase':\n                if (!preg_match('/[\\200-\\377]/', $str)) {\n                    // Can't use addslashes as we don't know the value of magic_quotes_sybase\n                    $encoded = addcslashes($str, \"\\0..\\37\\177\\\\\\\"\");\n                    if (($str == $encoded) && !preg_match('/[^A-Za-z0-9!#$%&\\'*+\\/=?^_`{|}~ -]/', $str)) {\n                        return ($encoded);\n                    } else {\n                        return (\"\\\"$encoded\\\"\");\n                    }\n                }\n                $matchcount = preg_match_all('/[^\\040\\041\\043-\\133\\135-\\176]/', $str, $matches);\n                break;\n            /** @noinspection PhpMissingBreakStatementInspection */\n            case 'comment':\n                $matchcount = preg_match_all('/[()\"]/', $str, $matches);\n                // Intentional fall-through\n            case 'text':\n            default:\n                $matchcount += preg_match_all('/[\\000-\\010\\013\\014\\016-\\037\\177-\\377]/', $str, $matches);\n                break;\n        }\n\n        //There are no chars that need encoding\n        if ($matchcount == 0) {\n            return ($str);\n        }\n\n        $maxlen = 75 - 7 - strlen($this->CharSet);\n        // Try to select the encoding which should produce the shortest output\n        if ($matchcount > strlen($str) / 3) {\n            // More than a third of the content will need encoding, so B encoding will be most efficient\n            $encoding = 'B';\n            if (function_exists('mb_strlen') && $this->hasMultiBytes($str)) {\n                // Use a custom function which correctly encodes and wraps long\n                // multibyte strings without breaking lines within a character\n                $encoded = $this->base64EncodeWrapMB($str, \"\\n\");\n            } else {\n                $encoded = base64_encode($str);\n                $maxlen -= $maxlen % 4;\n                $encoded = trim(chunk_split($encoded, $maxlen, \"\\n\"));\n            }\n        } else {\n            $encoding = 'Q';\n            $encoded = $this->encodeQ($str, $position);\n            $encoded = $this->wrapText($encoded, $maxlen, true);\n            $encoded = str_replace('=' . self::CRLF, \"\\n\", trim($encoded));\n        }\n\n        $encoded = preg_replace('/^(.*)$/m', ' =?' . $this->CharSet . \"?$encoding?\\\\1?=\", $encoded);\n        $encoded = trim(str_replace(\"\\n\", $this->LE, $encoded));\n\n        return $encoded;\n    }\n\n    /**\n     * Check if a string contains multi-byte characters.\n     * @access public\n     * @param string $str multi-byte text to wrap encode\n     * @return boolean\n     */\n    public function hasMultiBytes($str)\n    {\n        if (function_exists('mb_strlen')) {\n            return (strlen($str) > mb_strlen($str, $this->CharSet));\n        } else { // Assume no multibytes (we can't handle without mbstring functions anyway)\n            return false;\n        }\n    }\n\n    /**\n     * Does a string contain any 8-bit chars (in any charset)?\n     * @param string $text\n     * @return boolean\n     */\n    public function has8bitChars($text)\n    {\n        return (boolean)preg_match('/[\\x80-\\xFF]/', $text);\n    }\n\n    /**\n     * Encode and wrap long multibyte strings for mail headers\n     * without breaking lines within a character.\n     * Adapted from a function by paravoid\n     * @link http://www.php.net/manual/en/function.mb-encode-mimeheader.php#60283\n     * @access public\n     * @param string $str multi-byte text to wrap encode\n     * @param string $linebreak string to use as linefeed/end-of-line\n     * @return string\n     */\n    public function base64EncodeWrapMB($str, $linebreak = null)\n    {\n        $start = '=?' . $this->CharSet . '?B?';\n        $end = '?=';\n        $encoded = '';\n        if ($linebreak === null) {\n            $linebreak = $this->LE;\n        }\n\n        $mb_length = mb_strlen($str, $this->CharSet);\n        // Each line must have length <= 75, including $start and $end\n        $length = 75 - strlen($start) - strlen($end);\n        // Average multi-byte ratio\n        $ratio = $mb_length / strlen($str);\n        // Base64 has a 4:3 ratio\n        $avgLength = floor($length * $ratio * .75);\n\n        for ($i = 0; $i < $mb_length; $i += $offset) {\n            $lookBack = 0;\n            do {\n                $offset = $avgLength - $lookBack;\n                $chunk = mb_substr($str, $i, $offset, $this->CharSet);\n                $chunk = base64_encode($chunk);\n                $lookBack++;\n            } while (strlen($chunk) > $length);\n            $encoded .= $chunk . $linebreak;\n        }\n\n        // Chomp the last linefeed\n        $encoded = substr($encoded, 0, -strlen($linebreak));\n        return $encoded;\n    }\n\n    /**\n     * Encode a string in quoted-printable format.\n     * According to RFC2045 section 6.7.\n     * @access public\n     * @param string $string The text to encode\n     * @param integer $line_max Number of chars allowed on a line before wrapping\n     * @return string\n     * @link http://www.php.net/manual/en/function.quoted-printable-decode.php#89417 Adapted from this comment\n     */\n    public function encodeQP($string, $line_max = 76)\n    {\n        // Use native function if it's available (>= PHP5.3)\n        if (function_exists('quoted_printable_encode')) {\n            return quoted_printable_encode($string);\n        }\n        // Fall back to a pure PHP implementation\n        $string = str_replace(\n            array('%20', '%0D%0A.', '%0D%0A', '%'),\n            array(' ', \"\\r\\n=2E\", \"\\r\\n\", '='),\n            rawurlencode($string)\n        );\n        return preg_replace('/[^\\r\\n]{' . ($line_max - 3) . '}[^=\\r\\n]{2}/', \"$0=\\r\\n\", $string);\n    }\n\n    /**\n     * Backward compatibility wrapper for an old QP encoding function that was removed.\n     * @see PHPMailer::encodeQP()\n     * @access public\n     * @param string $string\n     * @param integer $line_max\n     * @param boolean $space_conv\n     * @return string\n     * @deprecated Use encodeQP instead.\n     */\n    public function encodeQPphp(\n        $string,\n        $line_max = 76,\n        /** @noinspection PhpUnusedParameterInspection */ $space_conv = false\n    ) {\n        return $this->encodeQP($string, $line_max);\n    }\n\n    /**\n     * Encode a string using Q encoding.\n     * @link http://tools.ietf.org/html/rfc2047\n     * @param string $str the text to encode\n     * @param string $position Where the text is going to be used, see the RFC for what that means\n     * @access public\n     * @return string\n     */\n    public function encodeQ($str, $position = 'text')\n    {\n        // There should not be any EOL in the string\n        $pattern = '';\n        $encoded = str_replace(array(\"\\r\", \"\\n\"), '', $str);\n        switch (strtolower($position)) {\n            case 'phrase':\n                // RFC 2047 section 5.3\n                $pattern = '^A-Za-z0-9!*+\\/ -';\n                break;\n            /** @noinspection PhpMissingBreakStatementInspection */\n            case 'comment':\n                // RFC 2047 section 5.2\n                $pattern = '\\(\\)\"';\n                // intentional fall-through\n                // for this reason we build the $pattern without including delimiters and []\n            case 'text':\n            default:\n                // RFC 2047 section 5.1\n                // Replace every high ascii, control, =, ? and _ characters\n                $pattern = '\\000-\\011\\013\\014\\016-\\037\\075\\077\\137\\177-\\377' . $pattern;\n                break;\n        }\n        $matches = array();\n        if (preg_match_all(\"/[{$pattern}]/\", $encoded, $matches)) {\n            // If the string contains an '=', make sure it's the first thing we replace\n            // so as to avoid double-encoding\n            $eqkey = array_search('=', $matches[0]);\n            if (false !== $eqkey) {\n                unset($matches[0][$eqkey]);\n                array_unshift($matches[0], '=');\n            }\n            foreach (array_unique($matches[0]) as $char) {\n                $encoded = str_replace($char, '=' . sprintf('%02X', ord($char)), $encoded);\n            }\n        }\n        // Replace every spaces to _ (more readable than =20)\n        return str_replace(' ', '_', $encoded);\n    }\n\n    /**\n     * Add a string or binary attachment (non-filesystem).\n     * This method can be used to attach ascii or binary data,\n     * such as a BLOB record from a database.\n     * @param string $string String attachment data.\n     * @param string $filename Name of the attachment.\n     * @param string $encoding File encoding (see $Encoding).\n     * @param string $type File extension (MIME) type.\n     * @param string $disposition Disposition to use\n     * @return void\n     */\n    public function addStringAttachment(\n        $string,\n        $filename,\n        $encoding = 'base64',\n        $type = '',\n        $disposition = 'attachment'\n    ) {\n        // If a MIME type is not specified, try to work it out from the file name\n        if ($type == '') {\n            $type = self::filenameToType($filename);\n        }\n        // Append to $attachment array\n        $this->attachment[] = array(\n            0 => $string,\n            1 => $filename,\n            2 => basename($filename),\n            3 => $encoding,\n            4 => $type,\n            5 => true, // isStringAttachment\n            6 => $disposition,\n            7 => 0\n        );\n    }\n\n    /**\n     * Add an embedded (inline) attachment from a file.\n     * This can include images, sounds, and just about any other document type.\n     * These differ from 'regular' attachments in that they are intended to be\n     * displayed inline with the message, not just attached for download.\n     * This is used in HTML messages that embed the images\n     * the HTML refers to using the $cid value.\n     * Never use a user-supplied path to a file!\n     * @param string $path Path to the attachment.\n     * @param string $cid Content ID of the attachment; Use this to reference\n     *        the content when using an embedded image in HTML.\n     * @param string $name Overrides the attachment name.\n     * @param string $encoding File encoding (see $Encoding).\n     * @param string $type File MIME type.\n     * @param string $disposition Disposition to use\n     * @return boolean True on successfully adding an attachment\n     */\n    public function addEmbeddedImage($path, $cid, $name = '', $encoding = 'base64', $type = '', $disposition = 'inline')\n    {\n        if (!self::isPermittedPath($path) or !@is_file($path)) {\n            $this->setError($this->lang('file_access') . $path);\n            return false;\n        }\n\n        // If a MIME type is not specified, try to work it out from the file name\n        if ($type == '') {\n            $type = self::filenameToType($path);\n        }\n\n        $filename = basename($path);\n        if ($name == '') {\n            $name = $filename;\n        }\n\n        // Append to $attachment array\n        $this->attachment[] = array(\n            0 => $path,\n            1 => $filename,\n            2 => $name,\n            3 => $encoding,\n            4 => $type,\n            5 => false, // isStringAttachment\n            6 => $disposition,\n            7 => $cid\n        );\n        return true;\n    }\n\n    /**\n     * Add an embedded stringified attachment.\n     * This can include images, sounds, and just about any other document type.\n     * Be sure to set the $type to an image type for images:\n     * JPEG images use 'image/jpeg', GIF uses 'image/gif', PNG uses 'image/png'.\n     * @param string $string The attachment binary data.\n     * @param string $cid Content ID of the attachment; Use this to reference\n     *        the content when using an embedded image in HTML.\n     * @param string $name\n     * @param string $encoding File encoding (see $Encoding).\n     * @param string $type MIME type.\n     * @param string $disposition Disposition to use\n     * @return boolean True on successfully adding an attachment\n     */\n    public function addStringEmbeddedImage(\n        $string,\n        $cid,\n        $name = '',\n        $encoding = 'base64',\n        $type = '',\n        $disposition = 'inline'\n    ) {\n        // If a MIME type is not specified, try to work it out from the name\n        if ($type == '' and !empty($name)) {\n            $type = self::filenameToType($name);\n        }\n\n        // Append to $attachment array\n        $this->attachment[] = array(\n            0 => $string,\n            1 => $name,\n            2 => $name,\n            3 => $encoding,\n            4 => $type,\n            5 => true, // isStringAttachment\n            6 => $disposition,\n            7 => $cid\n        );\n        return true;\n    }\n\n    /**\n     * Check if an inline attachment is present.\n     * @access public\n     * @return boolean\n     */\n    public function inlineImageExists()\n    {\n        foreach ($this->attachment as $attachment) {\n            if ($attachment[6] == 'inline') {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check if an attachment (non-inline) is present.\n     * @return boolean\n     */\n    public function attachmentExists()\n    {\n        foreach ($this->attachment as $attachment) {\n            if ($attachment[6] == 'attachment') {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check if this message has an alternative body set.\n     * @return boolean\n     */\n    public function alternativeExists()\n    {\n        return !empty($this->AltBody);\n    }\n\n    /**\n     * Clear queued addresses of given kind.\n     * @access protected\n     * @param string $kind 'to', 'cc', or 'bcc'\n     * @return void\n     */\n    public function clearQueuedAddresses($kind)\n    {\n        $RecipientsQueue = $this->RecipientsQueue;\n        foreach ($RecipientsQueue as $address => $params) {\n            if ($params[0] == $kind) {\n                unset($this->RecipientsQueue[$address]);\n            }\n        }\n    }\n\n    /**\n     * Clear all To recipients.\n     * @return void\n     */\n    public function clearAddresses()\n    {\n        foreach ($this->to as $to) {\n            unset($this->all_recipients[strtolower($to[0])]);\n        }\n        $this->to = array();\n        $this->clearQueuedAddresses('to');\n    }\n\n    /**\n     * Clear all CC recipients.\n     * @return void\n     */\n    public function clearCCs()\n    {\n        foreach ($this->cc as $cc) {\n            unset($this->all_recipients[strtolower($cc[0])]);\n        }\n        $this->cc = array();\n        $this->clearQueuedAddresses('cc');\n    }\n\n    /**\n     * Clear all BCC recipients.\n     * @return void\n     */\n    public function clearBCCs()\n    {\n        foreach ($this->bcc as $bcc) {\n            unset($this->all_recipients[strtolower($bcc[0])]);\n        }\n        $this->bcc = array();\n        $this->clearQueuedAddresses('bcc');\n    }\n\n    /**\n     * Clear all ReplyTo recipients.\n     * @return void\n     */\n    public function clearReplyTos()\n    {\n        $this->ReplyTo = array();\n        $this->ReplyToQueue = array();\n    }\n\n    /**\n     * Clear all recipient types.\n     * @return void\n     */\n    public function clearAllRecipients()\n    {\n        $this->to = array();\n        $this->cc = array();\n        $this->bcc = array();\n        $this->all_recipients = array();\n        $this->RecipientsQueue = array();\n    }\n\n    /**\n     * Clear all filesystem, string, and binary attachments.\n     * @return void\n     */\n    public function clearAttachments()\n    {\n        $this->attachment = array();\n    }\n\n    /**\n     * Clear all custom headers.\n     * @return void\n     */\n    public function clearCustomHeaders()\n    {\n        $this->CustomHeader = array();\n    }\n\n    /**\n     * Add an error message to the error container.\n     * @access protected\n     * @param string $msg\n     * @return void\n     */\n    protected function setError($msg)\n    {\n        $this->error_count++;\n        if ($this->Mailer == 'smtp' and !is_null($this->smtp)) {\n            $lasterror = $this->smtp->getError();\n            if (!empty($lasterror['error'])) {\n                $msg .= $this->lang('smtp_error') . $lasterror['error'];\n                if (!empty($lasterror['detail'])) {\n                    $msg .= ' Detail: '. $lasterror['detail'];\n                }\n                if (!empty($lasterror['smtp_code'])) {\n                    $msg .= ' SMTP code: ' . $lasterror['smtp_code'];\n                }\n                if (!empty($lasterror['smtp_code_ex'])) {\n                    $msg .= ' Additional SMTP info: ' . $lasterror['smtp_code_ex'];\n                }\n            }\n        }\n        $this->ErrorInfo = $msg;\n    }\n\n    /**\n     * Return an RFC 822 formatted date.\n     * @access public\n     * @return string\n     * @static\n     */\n    public static function rfcDate()\n    {\n        // Set the time zone to whatever the default is to avoid 500 errors\n        // Will default to UTC if it's not set properly in php.ini\n        date_default_timezone_set(@date_default_timezone_get());\n        return date('D, j M Y H:i:s O');\n    }\n\n    /**\n     * Get the server hostname.\n     * Returns 'localhost.localdomain' if unknown.\n     * @access protected\n     * @return string\n     */\n    protected function serverHostname()\n    {\n        $result = 'localhost.localdomain';\n        if (!empty($this->Hostname)) {\n            $result = $this->Hostname;\n        } elseif (isset($_SERVER) and array_key_exists('SERVER_NAME', $_SERVER) and !empty($_SERVER['SERVER_NAME'])) {\n            $result = $_SERVER['SERVER_NAME'];\n        } elseif (function_exists('gethostname') && gethostname() !== false) {\n            $result = gethostname();\n        } elseif (php_uname('n') !== false) {\n            $result = php_uname('n');\n        }\n        return $result;\n    }\n\n    /**\n     * Get an error message in the current language.\n     * @access protected\n     * @param string $key\n     * @return string\n     */\n    protected function lang($key)\n    {\n        if (count($this->language) < 1) {\n            $this->setLanguage('en'); // set the default language\n        }\n\n        if (array_key_exists($key, $this->language)) {\n            if ($key == 'smtp_connect_failed') {\n                //Include a link to troubleshooting docs on SMTP connection failure\n                //this is by far the biggest cause of support questions\n                //but it's usually not PHPMailer's fault.\n                return $this->language[$key] . ' https://github.com/PHPMailer/PHPMailer/wiki/Troubleshooting';\n            }\n            return $this->language[$key];\n        } else {\n            //Return the key as a fallback\n            return $key;\n        }\n    }\n\n    /**\n     * Check if an error occurred.\n     * @access public\n     * @return boolean True if an error did occur.\n     */\n    public function isError()\n    {\n        return ($this->error_count > 0);\n    }\n\n    /**\n     * Ensure consistent line endings in a string.\n     * Changes every end of line from CRLF, CR or LF to $this->LE.\n     * @access public\n     * @param string $str String to fixEOL\n     * @return string\n     */\n    public function fixEOL($str)\n    {\n        // Normalise to \\n\n        $nstr = str_replace(array(\"\\r\\n\", \"\\r\"), \"\\n\", $str);\n        // Now convert LE as needed\n        if ($this->LE !== \"\\n\") {\n            $nstr = str_replace(\"\\n\", $this->LE, $nstr);\n        }\n        return $nstr;\n    }\n\n    /**\n     * Add a custom header.\n     * $name value can be overloaded to contain\n     * both header name and value (name:value)\n     * @access public\n     * @param string $name Custom header name\n     * @param string $value Header value\n     * @return void\n     */\n    public function addCustomHeader($name, $value = null)\n    {\n        if ($value === null) {\n            // Value passed in as name:value\n            $this->CustomHeader[] = explode(':', $name, 2);\n        } else {\n            $this->CustomHeader[] = array($name, $value);\n        }\n    }\n\n    /**\n     * Returns all custom headers.\n     * @return array\n     */\n    public function getCustomHeaders()\n    {\n        return $this->CustomHeader;\n    }\n\n    /**\n     * Create a message body from an HTML string.\n     * Automatically inlines images and creates a plain-text version by converting the HTML,\n     * overwriting any existing values in Body and AltBody.\n     * Do not source $message content from user input!\n     * $basedir is prepended when handling relative URLs, e.g. <img src=\"/images/a.png\"> and must not be empty\n     * will look for an image file in $basedir/images/a.png and convert it to inline.\n     * If you don't provide a $basedir, relative paths will be left untouched (and thus probably break in email)\n     * If you don't want to apply these transformations to your HTML, just set Body and AltBody directly.\n     * @access public\n     * @param string $message HTML message string\n     * @param string $basedir Absolute path to a base directory to prepend to relative paths to images\n     * @param boolean|callable $advanced Whether to use the internal HTML to text converter\n     *    or your own custom converter @see PHPMailer::html2text()\n     * @return string $message The transformed message Body\n     */\n    public function msgHTML($message, $basedir = '', $advanced = false)\n    {\n        preg_match_all('/(src|background)=[\"\\'](.*)[\"\\']/Ui', $message, $images);\n        if (array_key_exists(2, $images)) {\n            if (strlen($basedir) > 1 && substr($basedir, -1) != '/') {\n                // Ensure $basedir has a trailing /\n                $basedir .= '/';\n            }\n            foreach ($images[2] as $imgindex => $url) {\n                // Convert data URIs into embedded images\n                if (preg_match('#^data:(image[^;,]*)(;base64)?,#', $url, $match)) {\n                    $data = substr($url, strpos($url, ','));\n                    if ($match[2]) {\n                        $data = base64_decode($data);\n                    } else {\n                        $data = rawurldecode($data);\n                    }\n                    $cid = md5($url) . '@phpmailer.0'; // RFC2392 S 2\n                    if ($this->addStringEmbeddedImage($data, $cid, 'embed' . $imgindex, 'base64', $match[1])) {\n                        $message = str_replace(\n                            $images[0][$imgindex],\n                            $images[1][$imgindex] . '=\"cid:' . $cid . '\"',\n                            $message\n                        );\n                    }\n                    continue;\n                }\n                if (\n                    // Only process relative URLs if a basedir is provided (i.e. no absolute local paths)\n                    !empty($basedir)\n                    // Ignore URLs containing parent dir traversal (..)\n                    && (strpos($url, '..') === false)\n                    // Do not change urls that are already inline images\n                    && substr($url, 0, 4) !== 'cid:'\n                    // Do not change absolute URLs, including anonymous protocol\n                    && !preg_match('#^[a-z][a-z0-9+.-]*:?//#i', $url)\n                ) {\n                    $filename = basename($url);\n                    $directory = dirname($url);\n                    if ($directory == '.') {\n                        $directory = '';\n                    }\n                    $cid = md5($url) . '@phpmailer.0'; // RFC2392 S 2\n                    if (strlen($directory) > 1 && substr($directory, -1) != '/') {\n                        $directory .= '/';\n                    }\n                    if ($this->addEmbeddedImage(\n                        $basedir . $directory . $filename,\n                        $cid,\n                        $filename,\n                        'base64',\n                        self::_mime_types((string)self::mb_pathinfo($filename, PATHINFO_EXTENSION))\n                    )\n                    ) {\n                        $message = preg_replace(\n                            '/' . $images[1][$imgindex] . '=[\"\\']' . preg_quote($url, '/') . '[\"\\']/Ui',\n                            $images[1][$imgindex] . '=\"cid:' . $cid . '\"',\n                            $message\n                        );\n                    }\n                }\n            }\n        }\n        $this->isHTML(true);\n        // Convert all message body line breaks to CRLF, makes quoted-printable encoding work much better\n        $this->Body = $this->normalizeBreaks($message);\n        $this->AltBody = $this->normalizeBreaks($this->html2text($message, $advanced));\n        if (!$this->alternativeExists()) {\n            $this->AltBody = 'To view this email message, open it in a program that understands HTML!' .\n                self::CRLF . self::CRLF;\n        }\n        return $this->Body;\n    }\n\n    /**\n     * Convert an HTML string into plain text.\n     * This is used by msgHTML().\n     * Note - older versions of this function used a bundled advanced converter\n     * which was been removed for license reasons in #232.\n     * Example usage:\n     * <code>\n     * // Use default conversion\n     * $plain = $mail->html2text($html);\n     * // Use your own custom converter\n     * $plain = $mail->html2text($html, function($html) {\n     *     $converter = new MyHtml2text($html);\n     *     return $converter->get_text();\n     * });\n     * </code>\n     * @param string $html The HTML text to convert\n     * @param boolean|callable $advanced Any boolean value to use the internal converter,\n     *   or provide your own callable for custom conversion.\n     * @return string\n     */\n    public function html2text($html, $advanced = false)\n    {\n        if (is_callable($advanced)) {\n            return call_user_func($advanced, $html);\n        }\n        return html_entity_decode(\n            trim(strip_tags(preg_replace('/<(head|title|style|script)[^>]*>.*?<\\/\\\\1>/si', '', $html))),\n            ENT_QUOTES,\n            $this->CharSet\n        );\n    }\n\n    /**\n     * Get the MIME type for a file extension.\n     * @param string $ext File extension\n     * @access public\n     * @return string MIME type of file.\n     * @static\n     */\n    public static function _mime_types($ext = '')\n    {\n        $mimes = array(\n            'xl'    => 'application/excel',\n            'js'    => 'application/javascript',\n            'hqx'   => 'application/mac-binhex40',\n            'cpt'   => 'application/mac-compactpro',\n            'bin'   => 'application/macbinary',\n            'doc'   => 'application/msword',\n            'word'  => 'application/msword',\n            'xlsx'  => 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            'xltx'  => 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',\n            'potx'  => 'application/vnd.openxmlformats-officedocument.presentationml.template',\n            'ppsx'  => 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',\n            'pptx'  => 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n            'sldx'  => 'application/vnd.openxmlformats-officedocument.presentationml.slide',\n            'docx'  => 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n            'dotx'  => 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',\n            'xlam'  => 'application/vnd.ms-excel.addin.macroEnabled.12',\n            'xlsb'  => 'application/vnd.ms-excel.sheet.binary.macroEnabled.12',\n            'class' => 'application/octet-stream',\n            'dll'   => 'application/octet-stream',\n            'dms'   => 'application/octet-stream',\n            'exe'   => 'application/octet-stream',\n            'lha'   => 'application/octet-stream',\n            'lzh'   => 'application/octet-stream',\n            'psd'   => 'application/octet-stream',\n            'sea'   => 'application/octet-stream',\n            'so'    => 'application/octet-stream',\n            'oda'   => 'application/oda',\n            'pdf'   => 'application/pdf',\n            'ai'    => 'application/postscript',\n            'eps'   => 'application/postscript',\n            'ps'    => 'application/postscript',\n            'smi'   => 'application/smil',\n            'smil'  => 'application/smil',\n            'mif'   => 'application/vnd.mif',\n            'xls'   => 'application/vnd.ms-excel',\n            'ppt'   => 'application/vnd.ms-powerpoint',\n            'wbxml' => 'application/vnd.wap.wbxml',\n            'wmlc'  => 'application/vnd.wap.wmlc',\n            'dcr'   => 'application/x-director',\n            'dir'   => 'application/x-director',\n            'dxr'   => 'application/x-director',\n            'dvi'   => 'application/x-dvi',\n            'gtar'  => 'application/x-gtar',\n            'php3'  => 'application/x-httpd-php',\n            'php4'  => 'application/x-httpd-php',\n            'php'   => 'application/x-httpd-php',\n            'phtml' => 'application/x-httpd-php',\n            'phps'  => 'application/x-httpd-php-source',\n            'swf'   => 'application/x-shockwave-flash',\n            'sit'   => 'application/x-stuffit',\n            'tar'   => 'application/x-tar',\n            'tgz'   => 'application/x-tar',\n            'xht'   => 'application/xhtml+xml',\n            'xhtml' => 'application/xhtml+xml',\n            'zip'   => 'application/zip',\n            'mid'   => 'audio/midi',\n            'midi'  => 'audio/midi',\n            'mp2'   => 'audio/mpeg',\n            'mp3'   => 'audio/mpeg',\n            'mpga'  => 'audio/mpeg',\n            'aif'   => 'audio/x-aiff',\n            'aifc'  => 'audio/x-aiff',\n            'aiff'  => 'audio/x-aiff',\n            'ram'   => 'audio/x-pn-realaudio',\n            'rm'    => 'audio/x-pn-realaudio',\n            'rpm'   => 'audio/x-pn-realaudio-plugin',\n            'ra'    => 'audio/x-realaudio',\n            'wav'   => 'audio/x-wav',\n            'bmp'   => 'image/bmp',\n            'gif'   => 'image/gif',\n            'jpeg'  => 'image/jpeg',\n            'jpe'   => 'image/jpeg',\n            'jpg'   => 'image/jpeg',\n            'png'   => 'image/png',\n            'tiff'  => 'image/tiff',\n            'tif'   => 'image/tiff',\n            'eml'   => 'message/rfc822',\n            'css'   => 'text/css',\n            'html'  => 'text/html',\n            'htm'   => 'text/html',\n            'shtml' => 'text/html',\n            'log'   => 'text/plain',\n            'text'  => 'text/plain',\n            'txt'   => 'text/plain',\n            'rtx'   => 'text/richtext',\n            'rtf'   => 'text/rtf',\n            'vcf'   => 'text/vcard',\n            'vcard' => 'text/vcard',\n            'xml'   => 'text/xml',\n            'xsl'   => 'text/xml',\n            'mpeg'  => 'video/mpeg',\n            'mpe'   => 'video/mpeg',\n            'mpg'   => 'video/mpeg',\n            'mov'   => 'video/quicktime',\n            'qt'    => 'video/quicktime',\n            'rv'    => 'video/vnd.rn-realvideo',\n            'avi'   => 'video/x-msvideo',\n            'movie' => 'video/x-sgi-movie'\n        );\n        if (array_key_exists(strtolower($ext), $mimes)) {\n            return $mimes[strtolower($ext)];\n        }\n        return 'application/octet-stream';\n    }\n\n    /**\n     * Map a file name to a MIME type.\n     * Defaults to 'application/octet-stream', i.e.. arbitrary binary data.\n     * @param string $filename A file name or full path, does not need to exist as a file\n     * @return string\n     * @static\n     */\n    public static function filenameToType($filename)\n    {\n        // In case the path is a URL, strip any query string before getting extension\n        $qpos = strpos($filename, '?');\n        if (false !== $qpos) {\n            $filename = substr($filename, 0, $qpos);\n        }\n        $pathinfo = self::mb_pathinfo($filename);\n        return self::_mime_types($pathinfo['extension']);\n    }\n\n    /**\n     * Multi-byte-safe pathinfo replacement.\n     * Drop-in replacement for pathinfo(), but multibyte-safe, cross-platform-safe, old-version-safe.\n     * Works similarly to the one in PHP >= 5.2.0\n     * @link http://www.php.net/manual/en/function.pathinfo.php#107461\n     * @param string $path A filename or path, does not need to exist as a file\n     * @param integer|string $options Either a PATHINFO_* constant,\n     *      or a string name to return only the specified piece, allows 'filename' to work on PHP < 5.2\n     * @return string|array\n     * @static\n     */\n    public static function mb_pathinfo($path, $options = null)\n    {\n        $ret = array('dirname' => '', 'basename' => '', 'extension' => '', 'filename' => '');\n        $pathinfo = array();\n        if (preg_match('%^(.*?)[\\\\\\\\/]*(([^/\\\\\\\\]*?)(\\.([^\\.\\\\\\\\/]+?)|))[\\\\\\\\/\\.]*$%im', $path, $pathinfo)) {\n            if (array_key_exists(1, $pathinfo)) {\n                $ret['dirname'] = $pathinfo[1];\n            }\n            if (array_key_exists(2, $pathinfo)) {\n                $ret['basename'] = $pathinfo[2];\n            }\n            if (array_key_exists(5, $pathinfo)) {\n                $ret['extension'] = $pathinfo[5];\n            }\n            if (array_key_exists(3, $pathinfo)) {\n                $ret['filename'] = $pathinfo[3];\n            }\n        }\n        switch ($options) {\n            case PATHINFO_DIRNAME:\n            case 'dirname':\n                return $ret['dirname'];\n            case PATHINFO_BASENAME:\n            case 'basename':\n                return $ret['basename'];\n            case PATHINFO_EXTENSION:\n            case 'extension':\n                return $ret['extension'];\n            case PATHINFO_FILENAME:\n            case 'filename':\n                return $ret['filename'];\n            default:\n                return $ret;\n        }\n    }\n\n    /**\n     * Set or reset instance properties.\n     * You should avoid this function - it's more verbose, less efficient, more error-prone and\n     * harder to debug than setting properties directly.\n     * Usage Example:\n     * `$mail->set('SMTPSecure', 'tls');`\n     *   is the same as:\n     * `$mail->SMTPSecure = 'tls';`\n     * @access public\n     * @param string $name The property name to set\n     * @param mixed $value The value to set the property to\n     * @return boolean\n     * @TODO Should this not be using the __set() magic function?\n     */\n    public function set($name, $value = '')\n    {\n        if (property_exists($this, $name)) {\n            $this->$name = $value;\n            return true;\n        } else {\n            $this->setError($this->lang('variable_set') . $name);\n            return false;\n        }\n    }\n\n    /**\n     * Strip newlines to prevent header injection.\n     * @access public\n     * @param string $str\n     * @return string\n     */\n    public function secureHeader($str)\n    {\n        return trim(str_replace(array(\"\\r\", \"\\n\"), '', $str));\n    }\n\n    /**\n     * Normalize line breaks in a string.\n     * Converts UNIX LF, Mac CR and Windows CRLF line breaks into a single line break format.\n     * Defaults to CRLF (for message bodies) and preserves consecutive breaks.\n     * @param string $text\n     * @param string $breaktype What kind of line break to use, defaults to CRLF\n     * @return string\n     * @access public\n     * @static\n     */\n    public static function normalizeBreaks($text, $breaktype = \"\\r\\n\")\n    {\n        return preg_replace('/(\\r\\n|\\r|\\n)/ms', $breaktype, $text);\n    }\n\n    /**\n     * Set the public and private key files and password for S/MIME signing.\n     * @access public\n     * @param string $cert_filename\n     * @param string $key_filename\n     * @param string $key_pass Password for private key\n     * @param string $extracerts_filename Optional path to chain certificate\n     */\n    public function sign($cert_filename, $key_filename, $key_pass, $extracerts_filename = '')\n    {\n        $this->sign_cert_file = $cert_filename;\n        $this->sign_key_file = $key_filename;\n        $this->sign_key_pass = $key_pass;\n        $this->sign_extracerts_file = $extracerts_filename;\n    }\n\n    /**\n     * Quoted-Printable-encode a DKIM header.\n     * @access public\n     * @param string $txt\n     * @return string\n     */\n    public function DKIM_QP($txt)\n    {\n        $line = '';\n        for ($i = 0; $i < strlen($txt); $i++) {\n            $ord = ord($txt[$i]);\n            if (((0x21 <= $ord) && ($ord <= 0x3A)) || $ord == 0x3C || ((0x3E <= $ord) && ($ord <= 0x7E))) {\n                $line .= $txt[$i];\n            } else {\n                $line .= '=' . sprintf('%02X', $ord);\n            }\n        }\n        return $line;\n    }\n\n    /**\n     * Generate a DKIM signature.\n     * @access public\n     * @param string $signHeader\n     * @throws phpmailerException\n     * @return string The DKIM signature value\n     */\n    public function DKIM_Sign($signHeader)\n    {\n        if (!defined('PKCS7_TEXT')) {\n            if ($this->exceptions) {\n                throw new phpmailerException($this->lang('extension_missing') . 'openssl');\n            }\n            return '';\n        }\n        $privKeyStr = !empty($this->DKIM_private_string) ? $this->DKIM_private_string : file_get_contents($this->DKIM_private);\n        if ('' != $this->DKIM_passphrase) {\n            $privKey = openssl_pkey_get_private($privKeyStr, $this->DKIM_passphrase);\n        } else {\n            $privKey = openssl_pkey_get_private($privKeyStr);\n        }\n        //Workaround for missing digest algorithms in old PHP & OpenSSL versions\n        //@link http://stackoverflow.com/a/11117338/333340\n        if (version_compare(PHP_VERSION, '5.3.0') >= 0 and\n            in_array('sha256WithRSAEncryption', openssl_get_md_methods(true))) {\n            if (openssl_sign($signHeader, $signature, $privKey, 'sha256WithRSAEncryption')) {\n                openssl_pkey_free($privKey);\n                return base64_encode($signature);\n            }\n        } else {\n            $pinfo = openssl_pkey_get_details($privKey);\n            $hash = hash('sha256', $signHeader);\n            //'Magic' constant for SHA256 from RFC3447\n            //@link https://tools.ietf.org/html/rfc3447#page-43\n            $t = '3031300d060960864801650304020105000420' . $hash;\n            $pslen = $pinfo['bits'] / 8 - (strlen($t) / 2 + 3);\n            $eb = pack('H*', '0001' . str_repeat('FF', $pslen) . '00' . $t);\n\n            if (openssl_private_encrypt($eb, $signature, $privKey, OPENSSL_NO_PADDING)) {\n                openssl_pkey_free($privKey);\n                return base64_encode($signature);\n            }\n        }\n        openssl_pkey_free($privKey);\n        return '';\n    }\n\n    /**\n     * Generate a DKIM canonicalization header.\n     * @access public\n     * @param string $signHeader Header\n     * @return string\n     */\n    public function DKIM_HeaderC($signHeader)\n    {\n        $signHeader = preg_replace('/\\r\\n\\s+/', ' ', $signHeader);\n        $lines = explode(\"\\r\\n\", $signHeader);\n        foreach ($lines as $key => $line) {\n            list($heading, $value) = explode(':', $line, 2);\n            $heading = strtolower($heading);\n            $value = preg_replace('/\\s{2,}/', ' ', $value); // Compress useless spaces\n            $lines[$key] = $heading . ':' . trim($value); // Don't forget to remove WSP around the value\n        }\n        $signHeader = implode(\"\\r\\n\", $lines);\n        return $signHeader;\n    }\n\n    /**\n     * Generate a DKIM canonicalization body.\n     * @access public\n     * @param string $body Message Body\n     * @return string\n     */\n    public function DKIM_BodyC($body)\n    {\n        if ($body == '') {\n            return \"\\r\\n\";\n        }\n        // stabilize line endings\n        $body = str_replace(\"\\r\\n\", \"\\n\", $body);\n        $body = str_replace(\"\\n\", \"\\r\\n\", $body);\n        // END stabilize line endings\n        while (substr($body, strlen($body) - 4, 4) == \"\\r\\n\\r\\n\") {\n            $body = substr($body, 0, strlen($body) - 2);\n        }\n        return $body;\n    }\n\n    /**\n     * Create the DKIM header and body in a new message header.\n     * @access public\n     * @param string $headers_line Header lines\n     * @param string $subject Subject\n     * @param string $body Body\n     * @return string\n     */\n    public function DKIM_Add($headers_line, $subject, $body)\n    {\n        $DKIMsignatureType = 'rsa-sha256'; // Signature & hash algorithms\n        $DKIMcanonicalization = 'relaxed/simple'; // Canonicalization of header/body\n        $DKIMquery = 'dns/txt'; // Query method\n        $DKIMtime = time(); // Signature Timestamp = seconds since 00:00:00 - Jan 1, 1970 (UTC time zone)\n        $subject_header = \"Subject: $subject\";\n        $headers = explode($this->LE, $headers_line);\n        $from_header = '';\n        $to_header = '';\n        $date_header = '';\n        $current = '';\n        foreach ($headers as $header) {\n            if (strpos($header, 'From:') === 0) {\n                $from_header = $header;\n                $current = 'from_header';\n            } elseif (strpos($header, 'To:') === 0) {\n                $to_header = $header;\n                $current = 'to_header';\n            } elseif (strpos($header, 'Date:') === 0) {\n                $date_header = $header;\n                $current = 'date_header';\n            } else {\n                if (!empty($$current) && strpos($header, ' =?') === 0) {\n                    $$current .= $header;\n                } else {\n                    $current = '';\n                }\n            }\n        }\n        $from = str_replace('|', '=7C', $this->DKIM_QP($from_header));\n        $to = str_replace('|', '=7C', $this->DKIM_QP($to_header));\n        $date = str_replace('|', '=7C', $this->DKIM_QP($date_header));\n        $subject = str_replace(\n            '|',\n            '=7C',\n            $this->DKIM_QP($subject_header)\n        ); // Copied header fields (dkim-quoted-printable)\n        $body = $this->DKIM_BodyC($body);\n        $DKIMlen = strlen($body); // Length of body\n        $DKIMb64 = base64_encode(pack('H*', hash('sha256', $body))); // Base64 of packed binary SHA-256 hash of body\n        if ('' == $this->DKIM_identity) {\n            $ident = '';\n        } else {\n            $ident = ' i=' . $this->DKIM_identity . ';';\n        }\n        $dkimhdrs = 'DKIM-Signature: v=1; a=' .\n            $DKIMsignatureType . '; q=' .\n            $DKIMquery . '; l=' .\n            $DKIMlen . '; s=' .\n            $this->DKIM_selector .\n            \";\\r\\n\" .\n            \"\\tt=\" . $DKIMtime . '; c=' . $DKIMcanonicalization . \";\\r\\n\" .\n            \"\\th=From:To:Date:Subject;\\r\\n\" .\n            \"\\td=\" . $this->DKIM_domain . ';' . $ident . \"\\r\\n\" .\n            \"\\tz=$from\\r\\n\" .\n            \"\\t|$to\\r\\n\" .\n            \"\\t|$date\\r\\n\" .\n            \"\\t|$subject;\\r\\n\" .\n            \"\\tbh=\" . $DKIMb64 . \";\\r\\n\" .\n            \"\\tb=\";\n        $toSign = $this->DKIM_HeaderC(\n            $from_header . \"\\r\\n\" .\n            $to_header . \"\\r\\n\" .\n            $date_header . \"\\r\\n\" .\n            $subject_header . \"\\r\\n\" .\n            $dkimhdrs\n        );\n        $signed = $this->DKIM_Sign($toSign);\n        return $dkimhdrs . $signed . \"\\r\\n\";\n    }\n\n    /**\n     * Detect if a string contains a line longer than the maximum line length allowed.\n     * @param string $str\n     * @return boolean\n     * @static\n     */\n    public static function hasLineLongerThanMax($str)\n    {\n        //+2 to include CRLF line break for a 1000 total\n        return (boolean)preg_match('/^(.{'.(self::MAX_LINE_LENGTH + 2).',})/m', $str);\n    }\n\n    /**\n     * Allows for public read access to 'to' property.\n     * @note: Before the send() call, queued addresses (i.e. with IDN) are not yet included.\n     * @access public\n     * @return array\n     */\n    public function getToAddresses()\n    {\n        return $this->to;\n    }\n\n    /**\n     * Allows for public read access to 'cc' property.\n     * @note: Before the send() call, queued addresses (i.e. with IDN) are not yet included.\n     * @access public\n     * @return array\n     */\n    public function getCcAddresses()\n    {\n        return $this->cc;\n    }\n\n    /**\n     * Allows for public read access to 'bcc' property.\n     * @note: Before the send() call, queued addresses (i.e. with IDN) are not yet included.\n     * @access public\n     * @return array\n     */\n    public function getBccAddresses()\n    {\n        return $this->bcc;\n    }\n\n    /**\n     * Allows for public read access to 'ReplyTo' property.\n     * @note: Before the send() call, queued addresses (i.e. with IDN) are not yet included.\n     * @access public\n     * @return array\n     */\n    public function getReplyToAddresses()\n    {\n        return $this->ReplyTo;\n    }\n\n    /**\n     * Allows for public read access to 'all_recipients' property.\n     * @note: Before the send() call, queued addresses (i.e. with IDN) are not yet included.\n     * @access public\n     * @return array\n     */\n    public function getAllRecipientAddresses()\n    {\n        return $this->all_recipients;\n    }\n\n    /**\n     * Perform a callback.\n     * @param boolean $isSent\n     * @param array $to\n     * @param array $cc\n     * @param array $bcc\n     * @param string $subject\n     * @param string $body\n     * @param string $from\n     */\n    protected function doCallback($isSent, $to, $cc, $bcc, $subject, $body, $from)\n    {\n        if (!empty($this->action_function) && is_callable($this->action_function)) {\n            $params = array($isSent, $to, $cc, $bcc, $subject, $body, $from);\n            call_user_func_array($this->action_function, $params);\n        }\n    }\n}\n\n/**\n * PHPMailer exception handler\n * @package PHPMailer\n */\nclass phpmailerException extends Exception\n{\n    /**\n     * Prettify error message output\n     * @return string\n     */\n    public function errorMessage()\n    {\n        $errorMsg = '<strong>' . htmlspecialchars($this->getMessage()) . \"</strong><br />\\n\";\n        return $errorMsg;\n    }\n}\n"],"file":"class.phpmailer.php"}