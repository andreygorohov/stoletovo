{"version":3,"names":[],"mappings":"","sources":["PHPMailer/extras/htmlfilter.php"],"sourcesContent":["<?php\n/**\n * htmlfilter.inc\n * ---------------\n * This set of functions allows you to filter html in order to remove\n * any malicious tags from it. Useful in cases when you need to filter\n * user input for any cross-site-scripting attempts.\n *\n * Copyright (C) 2002-2004 by Duke University\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301  USA\n *\n * @Author\tKonstantin Riabitsev <icon@linux.duke.edu>\n * @Author  Jim Jagielski <jim@jaguNET.com / jimjag@gmail.com>\n * @Version 1.1 ($Date$)\n */\n\n/**\n * This function returns the final tag out of the tag name, an array\n * of attributes, and the type of the tag. This function is called by\n * tln_sanitize internally.\n *\n * @param string $tagname the name of the tag.\n * @param array $attary the array of attributes and their values\n * @param integer $tagtype The type of the tag (see in comments).\n * @return string A string with the final tag representation.\n */\nfunction tln_tagprint($tagname, $attary, $tagtype)\n{\n    if ($tagtype == 2) {\n        $fulltag = '</' . $tagname . '>';\n    } else {\n        $fulltag = '<' . $tagname;\n        if (is_array($attary) && sizeof($attary)) {\n            $atts = array();\n            foreach($attary as $attname => $attvalue) {\n                array_push($atts, \"$attname=$attvalue\");\n            }\n            $fulltag .= ' ' . join(' ', $atts);\n        }\n        if ($tagtype == 3) {\n            $fulltag .= ' /';\n        }\n        $fulltag .= '>';\n    }\n    return $fulltag;\n}\n\n/**\n * A small helper function to use with array_walk. Modifies a by-ref\n * value and makes it lowercase.\n *\n * @param string $val a value passed by-ref.\n * @return\t\tvoid since it modifies a by-ref value.\n */\nfunction tln_casenormalize(&$val)\n{\n    $val = strtolower($val);\n}\n\n/**\n * This function skips any whitespace from the current position within\n * a string and to the next non-whitespace value.\n *\n * @param string $body the string\n * @param integer $offset the offset within the string where we should start\n *\t\t\t\t   looking for the next non-whitespace character.\n * @return integer          the location within the $body where the next\n *\t\t\t\t   non-whitespace char is located.\n */\nfunction tln_skipspace($body, $offset)\n{\n    preg_match('/^(\\s*)/s', substr($body, $offset), $matches);\n    if (sizeof($matches[1])) {\n        $count = strlen($matches[1]);\n        $offset += $count;\n    }\n    return $offset;\n}\n\n/**\n * This function looks for the next character within a string.\tIt's\n * really just a glorified \"strpos\", except it catches the failures\n * nicely.\n *\n * @param string $body   The string to look for needle in.\n * @param integer $offset Start looking from this position.\n * @param string $needle The character/string to look for.\n * @return integer           location of the next occurrence of the needle, or\n *\t\t\t\t   strlen($body) if needle wasn't found.\n */\nfunction tln_findnxstr($body, $offset, $needle)\n{\n    $pos = strpos($body, $needle, $offset);\n    if ($pos === false) {\n        $pos = strlen($body);\n    }\n    return $pos;\n}\n\n/**\n * This function takes a PCRE-style regexp and tries to match it\n * within the string.\n *\n * @param string $body   The string to look for needle in.\n * @param integer $offset Start looking from here.\n * @param string $reg       A PCRE-style regex to match.\n * @return array|boolean  Returns a false if no matches found, or an array\n *\t\t\t\t   with the following members:\n *\t\t\t\t   - integer with the location of the match within $body\n *\t\t\t\t   - string with whatever content between offset and the match\n *\t\t\t\t   - string with whatever it is we matched\n */\nfunction tln_findnxreg($body, $offset, $reg)\n{\n    $matches = array();\n    $retarr = array();\n    $preg_rule = '%^(.*?)(' . $reg . ')%s';\n    preg_match($preg_rule, substr($body, $offset), $matches);\n    if (!isset($matches[0]) || !$matches[0]) {\n        $retarr = false;\n    } else {\n        $retarr[0] = $offset + strlen($matches[1]);\n        $retarr[1] = $matches[1];\n        $retarr[2] = $matches[2];\n    }\n    return $retarr;\n}\n\n/**\n * This function looks for the next tag.\n *\n * @param string $body   String where to look for the next tag.\n * @param integer $offset Start looking from here.\n * @return array|boolean false if no more tags exist in the body, or\n *\t\t\t\t   an array with the following members:\n *\t\t\t\t   - string with the name of the tag\n *\t\t\t\t   - array with attributes and their values\n *\t\t\t\t   - integer with tag type (1, 2, or 3)\n *\t\t\t\t   - integer where the tag starts (starting \"<\")\n *\t\t\t\t   - integer where the tag ends (ending \">\")\n *\t\t\t\t   first three members will be false, if the tag is invalid.\n */\nfunction tln_getnxtag($body, $offset)\n{\n    if ($offset > strlen($body)) {\n        return false;\n    }\n    $lt = tln_findnxstr($body, $offset, '<');\n    if ($lt == strlen($body)) {\n        return false;\n    }\n    /**\n     * We are here:\n     * blah blah <tag attribute=\"value\">\n     * \\---------^\n     */\n    $pos = tln_skipspace($body, $lt + 1);\n    if ($pos >= strlen($body)) {\n        return array(false, false, false, $lt, strlen($body));\n    }\n    /**\n     * There are 3 kinds of tags:\n     * 1. Opening tag, e.g.:\n     *\t  <a href=\"blah\">\n     * 2. Closing tag, e.g.:\n     *\t  </a>\n     * 3. XHTML-style content-less tag, e.g.:\n     *\t  <img src=\"blah\"/>\n     */\n    switch (substr($body, $pos, 1)) {\n    case '/':\n        $tagtype = 2;\n        $pos++;\n        break;\n    case '!':\n        /**\n         * A comment or an SGML declaration.\n         */\n            if (substr($body, $pos + 1, 2) == '--') {\n            $gt = strpos($body, '-->', $pos);\n            if ($gt === false) {\n                $gt = strlen($body);\n            } else {\n                $gt += 2;\n            }\n            return array(false, false, false, $lt, $gt);\n        } else {\n            $gt = tln_findnxstr($body, $pos, '>');\n            return array(false, false, false, $lt, $gt);\n        }\n        break;\n    default:\n        /**\n         * Assume tagtype 1 for now. If it's type 3, we'll switch values\n         * later.\n         */\n        $tagtype = 1;\n        break;\n    }\n\n    /**\n     * Look for next [\\W-_], which will indicate the end of the tag name.\n     */\n    $regary = tln_findnxreg($body, $pos, '[^\\w\\-_]');\n    if ($regary == false) {\n        return array(false, false, false, $lt, strlen($body));\n    }\n    list($pos, $tagname, $match) = $regary;\n    $tagname = strtolower($tagname);\n\n    /**\n     * $match can be either of these:\n     * '>'\tindicating the end of the tag entirely.\n     * '\\s' indicating the end of the tag name.\n     * '/'\tindicating that this is type-3 xhtml tag.\n     *\n     * Whatever else we find there indicates an invalid tag.\n     */\n    switch ($match) {\n    case '/':\n        /**\n         * This is an xhtml-style tag with a closing / at the\n         * end, like so: <img src=\"blah\"/>. Check if it's followed\n         * by the closing bracket. If not, then this tag is invalid\n         */\n        if (substr($body, $pos, 2) == '/>') {\n            $pos++;\n            $tagtype = 3;\n        } else {\n            $gt = tln_findnxstr($body, $pos, '>');\n            $retary = array(false, false, false, $lt, $gt);\n            return $retary;\n        }\n            //intentional fall-through\n    case '>':\n        return array($tagname, false, $tagtype, $lt, $pos);\n        break;\n    default:\n        /**\n         * Check if it's whitespace\n         */\n        if (!preg_match('/\\s/', $match)) {\n            /**\n             * This is an invalid tag! Look for the next closing \">\".\n             */\n            $gt = tln_findnxstr($body, $lt, '>');\n            return array(false, false, false, $lt, $gt);\n        }\n        break;\n    }\n\n    /**\n     * At this point we're here:\n     * <tagname\t attribute='blah'>\n     * \\-------^\n     *\n     * At this point we loop in order to find all attributes.\n     */\n    $attary = array();\n\n    while ($pos <= strlen($body)) {\n        $pos = tln_skipspace($body, $pos);\n        if ($pos == strlen($body)) {\n            /**\n             * Non-closed tag.\n             */\n            return array(false, false, false, $lt, $pos);\n        }\n        /**\n         * See if we arrived at a \">\" or \"/>\", which means that we reached\n         * the end of the tag.\n         */\n        $matches = array();\n        if (preg_match('%^(\\s*)(>|/>)%s', substr($body, $pos), $matches)) {\n            /**\n             * Yep. So we did.\n             */\n            $pos += strlen($matches[1]);\n            if ($matches[2] == '/>') {\n                $tagtype = 3;\n                $pos++;\n            }\n            return array($tagname, $attary, $tagtype, $lt, $pos);\n        }\n\n        /**\n         * There are several types of attributes, with optional\n         * [:space:] between members.\n         * Type 1:\n         *\t attrname[:space:]=[:space:]'CDATA'\n         * Type 2:\n         *\t attrname[:space:]=[:space:]\"CDATA\"\n         * Type 3:\n         *\t attr[:space:]=[:space:]CDATA\n         * Type 4:\n         *\t attrname\n         *\n         * We leave types 1 and 2 the same, type 3 we check for\n         * '\"' and convert to \"&quot\" if needed, then wrap in\n         * double quotes. Type 4 we convert into:\n         * attrname=\"yes\".\n         */\n        $regary = tln_findnxreg($body, $pos, '[^\\w\\-_]');\n        if ($regary == false) {\n            /**\n             * Looks like body ended before the end of tag.\n             */\n            return array(false, false, false, $lt, strlen($body));\n        }\n        list($pos, $attname, $match) = $regary;\n        $attname = strtolower($attname);\n        /**\n         * We arrived at the end of attribute name. Several things possible\n         * here:\n         * '>'\tmeans the end of the tag and this is attribute type 4\n         * '/'\tif followed by '>' means the same thing as above\n         * '\\s' means a lot of things -- look what it's followed by.\n         *\t\tanything else means the attribute is invalid.\n         */\n        switch ($match) {\n        case '/':\n            /**\n             * This is an xhtml-style tag with a closing / at the\n             * end, like so: <img src=\"blah\"/>. Check if it's followed\n             * by the closing bracket. If not, then this tag is invalid\n             */\n            if (substr($body, $pos, 2) == '/>') {\n                $pos++;\n                $tagtype = 3;\n            } else {\n                $gt = tln_findnxstr($body, $pos, '>');\n                $retary = array(false, false, false, $lt, $gt);\n                return $retary;\n            }\n                //intentional fall-through\n        case '>':\n            $attary{$attname} = '\"yes\"';\n            return array($tagname, $attary, $tagtype, $lt, $pos);\n            break;\n        default:\n            /**\n             * Skip whitespace and see what we arrive at.\n             */\n            $pos = tln_skipspace($body, $pos);\n            $char = substr($body, $pos, 1);\n            /**\n             * Two things are valid here:\n             * '=' means this is attribute type 1 2 or 3.\n             * \\w means this was attribute type 4.\n             * anything else we ignore and re-loop. End of tag and\n             * invalid stuff will be caught by our checks at the beginning\n             * of the loop.\n             */\n            if ($char == '=') {\n                $pos++;\n                $pos = tln_skipspace($body, $pos);\n                /**\n                 * Here are 3 possibilities:\n                 * \"'\"\tattribute type 1\n                 * '\"'\tattribute type 2\n                 * everything else is the content of tag type 3\n                 */\n                $quot = substr($body, $pos, 1);\n                if ($quot == '\\'') {\n                        $regary = tln_findnxreg($body, $pos + 1, '\\'');\n                    if ($regary == false) {\n                        return array(false, false, false, $lt, strlen($body));\n                    }\n                    list($pos, $attval, $match) = $regary;\n                    $pos++;\n                    $attary{$attname} = '\\'' . $attval . '\\'';\n                } elseif ($quot == '\"') {\n                    $regary = tln_findnxreg($body, $pos + 1, '\\\"');\n                    if ($regary == false) {\n                        return array(false, false, false, $lt, strlen($body));\n                    }\n                    list($pos, $attval, $match) = $regary;\n                    $pos++;\n                            $attary{$attname} = '\"' . $attval . '\"';\n                } else {\n                    /**\n                     * These are hateful. Look for \\s, or >.\n                     */\n                    $regary = tln_findnxreg($body, $pos, '[\\s>]');\n                    if ($regary == false) {\n                        return array(false, false, false, $lt, strlen($body));\n                    }\n                    list($pos, $attval, $match) = $regary;\n                    /**\n                     * If it's \">\" it will be caught at the top.\n                     */\n                    $attval = preg_replace('/\\\"/s', '&quot;', $attval);\n                    $attary{$attname} = '\"' . $attval . '\"';\n                }\n            } elseif (preg_match('|[\\w/>]|', $char)) {\n                /**\n                 * That was attribute type 4.\n                 */\n                $attary{$attname} = '\"yes\"';\n            } else {\n                /**\n                 * An illegal character. Find next '>' and return.\n                 */\n                $gt = tln_findnxstr($body, $pos, '>');\n                return array(false, false, false, $lt, $gt);\n            }\n            break;\n        }\n    }\n    /**\n     * The fact that we got here indicates that the tag end was never\n     * found. Return invalid tag indication so it gets stripped.\n     */\n    return array(false, false, false, $lt, strlen($body));\n}\n\n/**\n * Translates entities into literal values so they can be checked.\n *\n * @param string $attvalue the by-ref value to check.\n * @param string $regex    the regular expression to check against.\n * @param boolean $hex        whether the entities are hexadecimal.\n * @return boolean            True or False depending on whether there were matches.\n */\nfunction tln_deent(&$attvalue, $regex, $hex = false)\n{\n    preg_match_all($regex, $attvalue, $matches);\n    if (is_array($matches) && sizeof($matches[0]) > 0) {\n        $repl = array();\n        for ($i = 0; $i < sizeof($matches[0]); $i++) {\n            $numval = $matches[1][$i];\n            if ($hex) {\n                $numval = hexdec($numval);\n            }\n            $repl{$matches[0][$i]} = chr($numval);\n        }\n        $attvalue = strtr($attvalue, $repl);\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * This function checks attribute values for entity-encoded values\n * and returns them translated into 8-bit strings so we can run\n * checks on them.\n *\n * @param string $attvalue A string to run entity check against.\n */\nfunction tln_defang(&$attvalue)\n{\n    /**\n     * Skip this if there aren't ampersands or backslashes.\n     */\n    if (strpos($attvalue, '&') === false\n        && strpos($attvalue, '\\\\') === false\n    ) {\n        return;\n    }\n    do {\n        $m = false;\n        $m = $m || tln_deent($attvalue, '/\\&#0*(\\d+);*/s');\n        $m = $m || tln_deent($attvalue, '/\\&#x0*((\\d|[a-f])+);*/si', true);\n        $m = $m || tln_deent($attvalue, '/\\\\\\\\(\\d+)/s', true);\n    } while ($m == true);\n    $attvalue = stripslashes($attvalue);\n}\n\n/**\n * Kill any tabs, newlines, or carriage returns. Our friends the\n * makers of the browser with 95% market value decided that it'd\n * be funny to make \"java[tab]script\" be just as good as \"javascript\".\n *\n * @param string $attvalue     The attribute value before extraneous spaces removed.\n */\nfunction tln_unspace(&$attvalue)\n{\n    if (strcspn($attvalue, \"\\t\\r\\n\\0 \") != strlen($attvalue)) {\n        $attvalue = str_replace(\n            array(\"\\t\", \"\\r\", \"\\n\", \"\\0\", \" \"),\n            array('', '', '', '', ''),\n            $attvalue\n        );\n    }\n}\n\n/**\n * This function runs various checks against the attributes.\n *\n * @param string $tagname            String with the name of the tag.\n * @param array $attary            Array with all tag attributes.\n * @param array $rm_attnames        See description for tln_sanitize\n * @param array $bad_attvals        See description for tln_sanitize\n * @param array $add_attr_to_tag See description for tln_sanitize\n * @param string $trans_image_path\n * @param boolean $block_external_images\n * @return array with modified attributes.\n */\nfunction tln_fixatts(\n    $tagname,\n    $attary,\n    $rm_attnames,\n    $bad_attvals,\n    $add_attr_to_tag,\n    $trans_image_path,\n    $block_external_images\n) {\n    foreach($attary as $attname => $attvalue) {\n        /**\n         * See if this attribute should be removed.\n         */\n        foreach ($rm_attnames as $matchtag => $matchattrs) {\n            if (preg_match($matchtag, $tagname)) {\n                foreach ($matchattrs as $matchattr) {\n                    if (preg_match($matchattr, $attname)) {\n                        unset($attary{$attname});\n                        continue;\n                    }\n                }\n            }\n        }\n        /**\n         * Remove any backslashes, entities, or extraneous whitespace.\n         */\n        $oldattvalue = $attvalue;\n        tln_defang($attvalue);\n        if ($attname == 'style' && $attvalue !== $oldattvalue) {\n            $attvalue = \"idiocy\";\n            $attary{$attname} = $attvalue;\n        }\n        tln_unspace($attvalue);\n\n        /**\n         * Now let's run checks on the attvalues.\n         * I don't expect anyone to comprehend this. If you do,\n         * get in touch with me so I can drive to where you live and\n         * shake your hand personally. :)\n         */\n        foreach ($bad_attvals as $matchtag => $matchattrs) {\n            if (preg_match($matchtag, $tagname)) {\n                foreach ($matchattrs as $matchattr => $valary) {\n                    if (preg_match($matchattr, $attname)) {\n                        /**\n                         * There are two arrays in valary.\n                         * First is matches.\n                         * Second one is replacements\n                         */\n                        list($valmatch, $valrepl) = $valary;\n                        $newvalue = preg_replace($valmatch, $valrepl, $attvalue);\n                        if ($newvalue != $attvalue) {\n                            $attary{$attname} = $newvalue;\n                            $attvalue = $newvalue;\n                        }\n                    }\n                }\n            }\n        }\n        if ($attname == 'style') {\n            if (preg_match('/[\\0-\\37\\200-\\377]+/', $attvalue)) {\n                $attary{$attname} = '\"disallowed character\"';\n            }\n            preg_match_all(\"/url\\s*\\((.+)\\)/si\", $attvalue, $aMatch);\n            if (count($aMatch)) {\n                foreach($aMatch[1] as $sMatch) {\n                    $urlvalue = $sMatch;\n                    tln_fixurl($attname, $urlvalue, $trans_image_path, $block_external_images);\n                    $attary{$attname} = str_replace($sMatch, $urlvalue, $attvalue);\n                }\n            }\n        }\n     }\n    /**\n     * See if we need to append any attributes to this tag.\n     */\n    foreach ($add_attr_to_tag as $matchtag => $addattary) {\n        if (preg_match($matchtag, $tagname)) {\n            $attary = array_merge($attary, $addattary);\n        }\n    }\n    return $attary;\n}\n\nfunction tln_fixurl($attname, &$attvalue, $trans_image_path, $block_external_images)\n{\n    $sQuote = '\"';\n    $attvalue = trim($attvalue);\n    if ($attvalue && ($attvalue[0] =='\"'|| $attvalue[0] == \"'\")) {\n        // remove the double quotes\n        $sQuote = $attvalue[0];\n        $attvalue = trim(substr($attvalue,1,-1));\n    }\n\n    /**\n     * Replace empty src tags with the blank image.  src is only used\n     * for frames, images, and image inputs.  Doing a replace should\n     * not affect them working as should be, however it will stop\n     * IE from being kicked off when src for img tags are not set\n     */\n    if ($attvalue == '') {\n        $attvalue = $sQuote . $trans_image_path . $sQuote;\n    } else {\n        // first, disallow 8 bit characters and control characters\n        if (preg_match('/[\\0-\\37\\200-\\377]+/',$attvalue)) {\n            switch ($attname) {\n                case 'href':\n                    $attvalue = $sQuote . 'http://invalid-stuff-detected.example.com' . $sQuote;\n                    break;\n                default:\n                    $attvalue = $sQuote . $trans_image_path . $sQuote;\n                    break;\n            }\n        } else {\n            $aUrl = parse_url($attvalue);\n            if (isset($aUrl['scheme'])) {\n                switch(strtolower($aUrl['scheme'])) {\n                    case 'mailto':\n                    case 'http':\n                    case 'https':\n                    case 'ftp':\n                        if ($attname != 'href') {\n                            if ($block_external_images == true) {\n                                $attvalue = $sQuote . $trans_image_path . $sQuote;\n                            } else {\n                                if (!isset($aUrl['path'])) {\n                                    $attvalue = $sQuote . $trans_image_path . $sQuote;\n                                }\n                            }\n                        } else {\n                            $attvalue = $sQuote . $attvalue . $sQuote;\n                        }\n                        break;\n                    case 'outbind':\n                        $attvalue = $sQuote . $attvalue . $sQuote;\n                        break;\n                    case 'cid':\n                        $attvalue = $sQuote . $attvalue . $sQuote;\n                        break;\n                    default:\n                        $attvalue = $sQuote . $trans_image_path . $sQuote;\n                        break;\n                }\n            } else {\n                if (!isset($aUrl['path']) || $aUrl['path'] != $trans_image_path) {\n                    $$attvalue = $sQuote . $trans_image_path . $sQuote;\n                }\n            }\n        }\n    }\n}\n\nfunction tln_fixstyle($body, $pos, $trans_image_path, $block_external_images)\n{\n    // workaround for </style> in between comments\n    $content = '';\n    $sToken = '';\n    $bSucces = false;\n    $bEndTag = false;\n    for ($i=$pos,$iCount=strlen($body);$i<$iCount;++$i) {\n        $char = $body{$i};\n        switch ($char) {\n            case '<':\n                $sToken = $char;\n                break;\n            case '/':\n                 if ($sToken == '<') {\n                    $sToken .= $char;\n                    $bEndTag = true;\n                 } else {\n                    $content .= $char;\n                 }\n                 break;\n            case '>':\n                 if ($bEndTag) {\n                    $sToken .= $char;\n                    if (preg_match('/\\<\\/\\s*style\\s*\\>/i',$sToken,$aMatch)) {\n                        $newpos = $i + 1;\n                        $bSucces = true;\n                        break 2;\n                    } else {\n                        $content .= $sToken;\n                    }\n                    $bEndTag = false;\n                 } else {\n                    $content .= $char;\n                 }\n                 break;\n            case '!':\n                if ($sToken == '<') {\n                    // possible comment\n                    if (isset($body{$i+2}) && substr($body,$i,3) == '!--') {\n                        $i = strpos($body,'-->',$i+3);\n                        if ($i === false) { // no end comment\n                            $i = strlen($body);\n                        }\n                        $sToken = '';\n                    }\n                } else {\n                    $content .= $char;\n                }\n                break;\n            default:\n                if ($bEndTag) {\n                    $sToken .= $char;\n                } else {\n                    $content .= $char;\n                }\n                break;\n        }\n    }\n    if ($bSucces == FALSE){\n        return array(FALSE, strlen($body));\n    }\n\n\n\n    /**\n     * First look for general BODY style declaration, which would be\n     * like so:\n     * body {background: blah-blah}\n     * and change it to .bodyclass so we can just assign it to a <div>\n     */\n    $content = preg_replace(\"|body(\\s*\\{.*?\\})|si\", \".bodyclass\\\\1\", $content);\n\n    /**\n    * Fix url('blah') declarations.\n    */\n    //   $content = preg_replace(\"|url\\s*\\(\\s*([\\'\\\"])\\s*\\S+script\\s*:.*?([\\'\\\"])\\s*\\)|si\",\n    //                           \"url(\\\\1$trans_image_path\\\\2)\", $content);\n\n    // first check for 8bit sequences and disallowed control characters\n    if (preg_match('/[\\16-\\37\\200-\\377]+/',$content)) {\n        $content = '<!-- style block removed by html filter due to presence of 8bit characters -->';\n        return array($content, $newpos);\n    }\n\n    // remove @import line\n    $content = preg_replace(\"/^\\s*(@import.*)$/mi\",\"\\n<!-- @import rules forbidden -->\\n\",$content);\n\n    $content = preg_replace(\"/(\\\\\\\\)?u(\\\\\\\\)?r(\\\\\\\\)?l(\\\\\\\\)?/i\", 'url', $content);\n    preg_match_all(\"/url\\s*\\((.+)\\)/si\",$content,$aMatch);\n    if (count($aMatch)) {\n        $aValue = $aReplace = array();\n        foreach($aMatch[1] as $sMatch) {\n            // url value\n            $urlvalue = $sMatch;\n            tln_fixurl('style',$urlvalue, $trans_image_path, $block_external_images);\n            $aValue[] = $sMatch;\n            $aReplace[] = $urlvalue;\n        }\n        $content = str_replace($aValue,$aReplace,$content);\n    }\n\n    /**\n     * Remove any backslashes, entities, and extraneous whitespace.\n     */\n    $contentTemp = $content;\n    tln_defang($contentTemp);\n    tln_unspace($contentTemp);\n\n    $match   = array('/\\/\\*.*\\*\\//',\n                    '/expression/i',\n                    '/behaviou*r/i',\n                    '/binding/i',\n                    '/include-source/i',\n                    '/javascript/i',\n                    '/script/i',\n                    '/position/i');\n    $replace = array('','idiocy', 'idiocy', 'idiocy', 'idiocy', 'idiocy', 'idiocy', '');\n    $contentNew = preg_replace($match, $replace, $contentTemp);\n    if ($contentNew !== $contentTemp) {\n        $content = $contentNew;\n    }\n    return array($content, $newpos);\n}\n\nfunction tln_body2div($attary, $trans_image_path)\n{\n    $divattary = array('class' => \"'bodyclass'\");\n    $text = '#000000';\n    $has_bgc_stl = $has_txt_stl = false;\n    $styledef = '';\n    if (is_array($attary) && sizeof($attary) > 0){\n        foreach ($attary as $attname=>$attvalue){\n            $quotchar = substr($attvalue, 0, 1);\n            $attvalue = str_replace($quotchar, \"\", $attvalue);\n            switch ($attname){\n                case 'background':\n                    $styledef .= \"background-image: url('$trans_image_path'); \";\n                    break;\n                case 'bgcolor':\n                    $has_bgc_stl = true;\n                    $styledef .= \"background-color: $attvalue; \";\n                    break;\n                case 'text':\n                    $has_txt_stl = true;\n                    $styledef .= \"color: $attvalue; \";\n                    break;\n            }\n        }\n        // Outlook defines a white bgcolor and no text color. This can lead to\n        // white text on a white bg with certain themes.\n        if ($has_bgc_stl && !$has_txt_stl) {\n            $styledef .= \"color: $text; \";\n        }\n        if (strlen($styledef) > 0){\n            $divattary{\"style\"} = \"\\\"$styledef\\\"\";\n        }\n    }\n    return $divattary;\n}\n\n/**\n *\n * @param string $body                    The HTML you wish to filter\n * @param array $tag_list                see description above\n * @param array $rm_tags_with_content see description above\n * @param array $self_closing_tags    see description above\n * @param boolean $force_tag_closing    see description above\n * @param array $rm_attnames            see description above\n * @param array $bad_attvals            see description above\n * @param array $add_attr_to_tag        see description above\n * @param string $trans_image_path\n * @param boolean $block_external_images\n\n * @return string                       Sanitized html safe to show on your pages.\n */\nfunction tln_sanitize(\n    $body,\n    $tag_list,\n    $rm_tags_with_content,\n    $self_closing_tags,\n    $force_tag_closing,\n    $rm_attnames,\n    $bad_attvals,\n    $add_attr_to_tag,\n    $trans_image_path,\n    $block_external_images\n) {\n    /**\n     * Normalize rm_tags and rm_tags_with_content.\n     */\n    $rm_tags = array_shift($tag_list);\n    @array_walk($tag_list, 'tln_casenormalize');\n    @array_walk($rm_tags_with_content, 'tln_casenormalize');\n    @array_walk($self_closing_tags, 'tln_casenormalize');\n    /**\n     * See if tag_list is of tags to remove or tags to allow.\n     * false  means remove these tags\n     * true\t  means allow these tags\n     */\n    $curpos = 0;\n    $open_tags = array();\n    $trusted = \"<!-- begin tln_sanitized html -->\\n\";\n    $skip_content = false;\n    /**\n     * Take care of netscape's stupid javascript entities like\n     * &{alert('boo')};\n     */\n    $body = preg_replace('/&(\\{.*?\\};)/si', '&amp;\\\\1', $body);\n    while (($curtag = tln_getnxtag($body, $curpos)) != false) {\n        list($tagname, $attary, $tagtype, $lt, $gt) = $curtag;\n        $free_content = substr($body, $curpos, $lt-$curpos);\n        /**\n         * Take care of <style>\n         */\n        if ($tagname == \"style\" && $tagtype == 1){\n            list($free_content, $curpos) =\n                tln_fixstyle($body, $gt+1, $trans_image_path, $block_external_images);\n            if ($free_content != FALSE){\n                if ( !empty($attary) ) {\n                    $attary = tln_fixatts($tagname,\n                                         $attary,\n                                         $rm_attnames,\n                                         $bad_attvals,\n                                         $add_attr_to_tag,\n                                         $trans_image_path,\n                                         $block_external_images\n                                         );\n                }\n                $trusted .= tln_tagprint($tagname, $attary, $tagtype);\n                $trusted .= $free_content;\n                $trusted .= tln_tagprint($tagname, null, 2);\n            }\n            continue;\n        }\n        if ($skip_content == false){\n            $trusted .= $free_content;\n        }\n        if ($tagname != false) {\n            if ($tagtype == 2) {\n                if ($skip_content == $tagname) {\n                    /**\n                     * Got to the end of tag we needed to remove.\n                     */\n                    $tagname = false;\n                    $skip_content = false;\n                } else {\n                    if ($skip_content == false) {\n                        if ($tagname == \"body\") {\n                            $tagname = \"div\";\n                        }\n                        if (isset($open_tags{$tagname}) &&\n                            $open_tags{$tagname} > 0\n                        ) {\n                            $open_tags{$tagname}--;\n                        } else {\n                            $tagname = false;\n                        }\n                    }\n                }\n            } else {\n                /**\n                 * $rm_tags_with_content\n                 */\n                if ($skip_content == false) {\n                    /**\n                     * See if this is a self-closing type and change\n                     * tagtype appropriately.\n                     */\n                    if ($tagtype == 1\n                        && in_array($tagname, $self_closing_tags)\n                    ) {\n                        $tagtype = 3;\n                    }\n                    /**\n                     * See if we should skip this tag and any content\n                     * inside it.\n                     */\n                    if ($tagtype == 1\n                        && in_array($tagname, $rm_tags_with_content)\n                    ) {\n                        $skip_content = $tagname;\n                    } else {\n                        if (($rm_tags == false\n                             && in_array($tagname, $tag_list)) ||\n                            ($rm_tags == true\n                                && !in_array($tagname, $tag_list))\n                        ) {\n                            $tagname = false;\n                        } else {\n                            /**\n                             * Convert body into div.\n                             */\n                            if ($tagname == \"body\"){\n                                $tagname = \"div\";\n                                $attary = tln_body2div($attary, $trans_image_path);\n                            }\n                            if ($tagtype == 1) {\n                                if (isset($open_tags{$tagname})) {\n                                    $open_tags{$tagname}++;\n                                } else {\n                                    $open_tags{$tagname} = 1;\n                                }\n                            }\n                            /**\n                             * This is where we run other checks.\n                             */\n                            if (is_array($attary) && sizeof($attary) > 0) {\n                                $attary = tln_fixatts(\n                                    $tagname,\n                                    $attary,\n                                    $rm_attnames,\n                                    $bad_attvals,\n                                    $add_attr_to_tag,\n                                    $trans_image_path,\n                                    $block_external_images\n                                );\n                            }\n                        }\n                    }\n                }\n            }\n            if ($tagname != false && $skip_content == false) {\n                $trusted .= tln_tagprint($tagname, $attary, $tagtype);\n            }\n        }\n        $curpos = $gt + 1;\n    }\n    $trusted .= substr($body, $curpos, strlen($body) - $curpos);\n    if ($force_tag_closing == true) {\n        foreach ($open_tags as $tagname => $opentimes) {\n            while ($opentimes > 0) {\n                $trusted .= '</' . $tagname . '>';\n                $opentimes--;\n            }\n        }\n        $trusted .= \"\\n\";\n    }\n    $trusted .= \"<!-- end tln_sanitized html -->\\n\";\n    return $trusted;\n}\n\n//\n// Use the nifty htmlfilter library\n//\n\n\nfunction HTMLFilter($body, $trans_image_path, $block_external_images = false)\n{\n\n    $tag_list = array(\n        false,\n        \"object\",\n        \"meta\",\n        \"html\",\n        \"head\",\n        \"base\",\n        \"link\",\n        \"frame\",\n        \"iframe\",\n        \"plaintext\",\n        \"marquee\"\n    );\n\n    $rm_tags_with_content = array(\n        \"script\",\n        \"applet\",\n        \"embed\",\n        \"title\",\n        \"frameset\",\n        \"xmp\",\n        \"xml\"\n    );\n\n    $self_closing_tags =  array(\n        \"img\",\n        \"br\",\n        \"hr\",\n        \"input\",\n        \"outbind\"\n    );\n\n    $force_tag_closing = true;\n\n    $rm_attnames = array(\n        \"/.*/\" =>\n            array(\n                // \"/target/i\",\n                \"/^on.*/i\",\n                \"/^dynsrc/i\",\n                \"/^data.*/i\",\n                \"/^lowsrc.*/i\"\n            )\n    );\n\n    $bad_attvals = array(\n        \"/.*/\" =>\n        array(\n            \"/^src|background/i\" =>\n            array(\n                array(\n                    '/^([\\'\"])\\s*\\S+script\\s*:.*([\\'\"])/si',\n                    '/^([\\'\"])\\s*mocha\\s*:*.*([\\'\"])/si',\n                    '/^([\\'\"])\\s*about\\s*:.*([\\'\"])/si'\n                ),\n                array(\n                    \"\\\\1$trans_image_path\\\\2\",\n                    \"\\\\1$trans_image_path\\\\2\",\n                    \"\\\\1$trans_image_path\\\\2\"\n                )\n            ),\n            \"/^href|action/i\" =>\n            array(\n                array(\n                    '/^([\\'\"])\\s*\\S+script\\s*:.*([\\'\"])/si',\n                    '/^([\\'\"])\\s*mocha\\s*:*.*([\\'\"])/si',\n                    '/^([\\'\"])\\s*about\\s*:.*([\\'\"])/si'\n                ),\n                array(\n                    \"\\\\1#\\\\1\",\n                    \"\\\\1#\\\\1\",\n                    \"\\\\1#\\\\1\"\n                )\n            ),\n            \"/^style/i\" =>\n            array(\n                array(\n                    \"/\\/\\*.*\\*\\//\",\n                    \"/expression/i\",\n                    \"/binding/i\",\n                    \"/behaviou*r/i\",\n                    \"/include-source/i\",\n                    '/position\\s*:/i',\n                    '/(\\\\\\\\)?u(\\\\\\\\)?r(\\\\\\\\)?l(\\\\\\\\)?/i',\n                    '/url\\s*\\(\\s*([\\'\"])\\s*\\S+script\\s*:.*([\\'\"])\\s*\\)/si',\n                    '/url\\s*\\(\\s*([\\'\"])\\s*mocha\\s*:.*([\\'\"])\\s*\\)/si',\n                    '/url\\s*\\(\\s*([\\'\"])\\s*about\\s*:.*([\\'\"])\\s*\\)/si',\n                    '/(.*)\\s*:\\s*url\\s*\\(\\s*([\\'\"]*)\\s*\\S+script\\s*:.*([\\'\"]*)\\s*\\)/si'\n                ),\n                array(\n                    \"\",\n                    \"idiocy\",\n                    \"idiocy\",\n                    \"idiocy\",\n                    \"idiocy\",\n                    \"idiocy\",\n                    \"url\",\n                    \"url(\\\\1#\\\\1)\",\n                    \"url(\\\\1#\\\\1)\",\n                    \"url(\\\\1#\\\\1)\",\n                    \"\\\\1:url(\\\\2#\\\\3)\"\n                )\n            )\n        )\n    );\n\n    if ($block_external_images) {\n        array_push(\n            $bad_attvals{'/.*/'}{'/^src|background/i'}[0],\n            '/^([\\'\\\"])\\s*https*:.*([\\'\\\"])/si'\n        );\n        array_push(\n            $bad_attvals{'/.*/'}{'/^src|background/i'}[1],\n            \"\\\\1$trans_image_path\\\\1\"\n        );\n        array_push(\n            $bad_attvals{'/.*/'}{'/^style/i'}[0],\n            '/url\\(([\\'\\\"])\\s*https*:.*([\\'\\\"])\\)/si'\n        );\n        array_push(\n            $bad_attvals{'/.*/'}{'/^style/i'}[1],\n            \"url(\\\\1$trans_image_path\\\\1)\"\n        );\n    }\n\n    $add_attr_to_tag = array(\n        \"/^a$/i\" =>\n            array('target' => '\"_blank\"')\n    );\n\n    $trusted = tln_sanitize(\n        $body,\n        $tag_list,\n        $rm_tags_with_content,\n        $self_closing_tags,\n        $force_tag_closing,\n        $rm_attnames,\n        $bad_attvals,\n        $add_attr_to_tag,\n        $trans_image_path,\n        $block_external_images\n    );\n    return $trusted;\n}\n"],"file":"htmlfilter.php"}