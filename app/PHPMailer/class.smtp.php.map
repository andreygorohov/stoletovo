{"version":3,"names":[],"mappings":"","sources":["PHPMailer/class.smtp.php"],"sourcesContent":["<?php\n/**\n * PHPMailer RFC821 SMTP email transport class.\n * PHP Version 5\n * @package PHPMailer\n * @link https://github.com/PHPMailer/PHPMailer/ The PHPMailer GitHub project\n * @author Marcus Bointon (Synchro/coolbru) <phpmailer@synchromedia.co.uk>\n * @author Jim Jagielski (jimjag) <jimjag@gmail.com>\n * @author Andy Prevost (codeworxtech) <codeworxtech@users.sourceforge.net>\n * @author Brent R. Matzelle (original founder)\n * @copyright 2014 Marcus Bointon\n * @copyright 2010 - 2012 Jim Jagielski\n * @copyright 2004 - 2009 Andy Prevost\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n * @note This program is distributed in the hope that it will be useful - WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.\n */\n\n/**\n * PHPMailer RFC821 SMTP email transport class.\n * Implements RFC 821 SMTP commands and provides some utility methods for sending mail to an SMTP server.\n * @package PHPMailer\n * @author Chris Ryan\n * @author Marcus Bointon <phpmailer@synchromedia.co.uk>\n */\nclass SMTP\n{\n    /**\n     * The PHPMailer SMTP version number.\n     * @var string\n     */\n    const VERSION = '5.2.27';\n\n    /**\n     * SMTP line break constant.\n     * @var string\n     */\n    const CRLF = \"\\r\\n\";\n\n    /**\n     * The SMTP port to use if one is not specified.\n     * @var integer\n     */\n    const DEFAULT_SMTP_PORT = 25;\n\n    /**\n     * The maximum line length allowed by RFC 2822 section 2.1.1\n     * @var integer\n     */\n    const MAX_LINE_LENGTH = 998;\n\n    /**\n     * Debug level for no output\n     */\n    const DEBUG_OFF = 0;\n\n    /**\n     * Debug level to show client -> server messages\n     */\n    const DEBUG_CLIENT = 1;\n\n    /**\n     * Debug level to show client -> server and server -> client messages\n     */\n    const DEBUG_SERVER = 2;\n\n    /**\n     * Debug level to show connection status, client -> server and server -> client messages\n     */\n    const DEBUG_CONNECTION = 3;\n\n    /**\n     * Debug level to show all messages\n     */\n    const DEBUG_LOWLEVEL = 4;\n\n    /**\n     * The PHPMailer SMTP Version number.\n     * @var string\n     * @deprecated Use the `VERSION` constant instead\n     * @see SMTP::VERSION\n     */\n    public $Version = '5.2.27';\n\n    /**\n     * SMTP server port number.\n     * @var integer\n     * @deprecated This is only ever used as a default value, so use the `DEFAULT_SMTP_PORT` constant instead\n     * @see SMTP::DEFAULT_SMTP_PORT\n     */\n    public $SMTP_PORT = 25;\n\n    /**\n     * SMTP reply line ending.\n     * @var string\n     * @deprecated Use the `CRLF` constant instead\n     * @see SMTP::CRLF\n     */\n    public $CRLF = \"\\r\\n\";\n\n    /**\n     * Debug output level.\n     * Options:\n     * * self::DEBUG_OFF (`0`) No debug output, default\n     * * self::DEBUG_CLIENT (`1`) Client commands\n     * * self::DEBUG_SERVER (`2`) Client commands and server responses\n     * * self::DEBUG_CONNECTION (`3`) As DEBUG_SERVER plus connection status\n     * * self::DEBUG_LOWLEVEL (`4`) Low-level data output, all messages\n     * @var integer\n     */\n    public $do_debug = self::DEBUG_OFF;\n\n    /**\n     * How to handle debug output.\n     * Options:\n     * * `echo` Output plain-text as-is, appropriate for CLI\n     * * `html` Output escaped, line breaks converted to `<br>`, appropriate for browser output\n     * * `error_log` Output to error log as configured in php.ini\n     *\n     * Alternatively, you can provide a callable expecting two params: a message string and the debug level:\n     * <code>\n     * $smtp->Debugoutput = function($str, $level) {echo \"debug level $level; message: $str\";};\n     * </code>\n     * @var string|callable\n     */\n    public $Debugoutput = 'echo';\n\n    /**\n     * Whether to use VERP.\n     * @link http://en.wikipedia.org/wiki/Variable_envelope_return_path\n     * @link http://www.postfix.org/VERP_README.html Info on VERP\n     * @var boolean\n     */\n    public $do_verp = false;\n\n    /**\n     * The timeout value for connection, in seconds.\n     * Default of 5 minutes (300sec) is from RFC2821 section 4.5.3.2\n     * This needs to be quite high to function correctly with hosts using greetdelay as an anti-spam measure.\n     * @link http://tools.ietf.org/html/rfc2821#section-4.5.3.2\n     * @var integer\n     */\n    public $Timeout = 300;\n\n    /**\n     * How long to wait for commands to complete, in seconds.\n     * Default of 5 minutes (300sec) is from RFC2821 section 4.5.3.2\n     * @var integer\n     */\n    public $Timelimit = 300;\n\n    /**\n     * @var array Patterns to extract an SMTP transaction id from reply to a DATA command.\n     * The first capture group in each regex will be used as the ID.\n     */\n    protected $smtp_transaction_id_patterns = array(\n        'exim' => '/[0-9]{3} OK id=(.*)/',\n        'sendmail' => '/[0-9]{3} 2.0.0 (.*) Message/',\n        'postfix' => '/[0-9]{3} 2.0.0 Ok: queued as (.*)/'\n    );\n\n    /**\n     * @var string The last transaction ID issued in response to a DATA command,\n     * if one was detected\n     */\n    protected $last_smtp_transaction_id;\n\n    /**\n     * The socket for the server connection.\n     * @var resource\n     */\n    protected $smtp_conn;\n\n    /**\n     * Error information, if any, for the last SMTP command.\n     * @var array\n     */\n    protected $error = array(\n        'error' => '',\n        'detail' => '',\n        'smtp_code' => '',\n        'smtp_code_ex' => ''\n    );\n\n    /**\n     * The reply the server sent to us for HELO.\n     * If null, no HELO string has yet been received.\n     * @var string|null\n     */\n    protected $helo_rply = null;\n\n    /**\n     * The set of SMTP extensions sent in reply to EHLO command.\n     * Indexes of the array are extension names.\n     * Value at index 'HELO' or 'EHLO' (according to command that was sent)\n     * represents the server name. In case of HELO it is the only element of the array.\n     * Other values can be boolean TRUE or an array containing extension options.\n     * If null, no HELO/EHLO string has yet been received.\n     * @var array|null\n     */\n    protected $server_caps = null;\n\n    /**\n     * The most recent reply received from the server.\n     * @var string\n     */\n    protected $last_reply = '';\n\n    /**\n     * Output debugging info via a user-selected method.\n     * @see SMTP::$Debugoutput\n     * @see SMTP::$do_debug\n     * @param string $str Debug string to output\n     * @param integer $level The debug level of this message; see DEBUG_* constants\n     * @return void\n     */\n    protected function edebug($str, $level = 0)\n    {\n        if ($level > $this->do_debug) {\n            return;\n        }\n        //Avoid clash with built-in function names\n        if (!in_array($this->Debugoutput, array('error_log', 'html', 'echo')) and is_callable($this->Debugoutput)) {\n            call_user_func($this->Debugoutput, $str, $level);\n            return;\n        }\n        switch ($this->Debugoutput) {\n            case 'error_log':\n                //Don't output, just log\n                error_log($str);\n                break;\n            case 'html':\n                //Cleans up output a bit for a better looking, HTML-safe output\n                echo gmdate('Y-m-d H:i:s') . ' ' . htmlentities(\n                    preg_replace('/[\\r\\n]+/', '', $str),\n                    ENT_QUOTES,\n                    'UTF-8'\n                ) . \"<br>\\n\";\n                break;\n            case 'echo':\n            default:\n                //Normalize line breaks\n                $str = preg_replace('/(\\r\\n|\\r|\\n)/ms', \"\\n\", $str);\n                echo gmdate('Y-m-d H:i:s') . \"\\t\" . str_replace(\n                    \"\\n\",\n                    \"\\n                   \\t                  \",\n                    trim($str)\n                ) . \"\\n\";\n        }\n    }\n\n    /**\n     * Connect to an SMTP server.\n     * @param string $host SMTP server IP or host name\n     * @param integer $port The port number to connect to\n     * @param integer $timeout How long to wait for the connection to open\n     * @param array $options An array of options for stream_context_create()\n     * @access public\n     * @return boolean\n     */\n    public function connect($host, $port = null, $timeout = 30, $options = array())\n    {\n        static $streamok;\n        //This is enabled by default since 5.0.0 but some providers disable it\n        //Check this once and cache the result\n        if (is_null($streamok)) {\n            $streamok = function_exists('stream_socket_client');\n        }\n        // Clear errors to avoid confusion\n        $this->setError('');\n        // Make sure we are __not__ connected\n        if ($this->connected()) {\n            // Already connected, generate error\n            $this->setError('Already connected to a server');\n            return false;\n        }\n        if (empty($port)) {\n            $port = self::DEFAULT_SMTP_PORT;\n        }\n        // Connect to the SMTP server\n        $this->edebug(\n            \"Connection: opening to $host:$port, timeout=$timeout, options=\" .\n            var_export($options, true),\n            self::DEBUG_CONNECTION\n        );\n        $errno = 0;\n        $errstr = '';\n        if ($streamok) {\n            $socket_context = stream_context_create($options);\n            set_error_handler(array($this, 'errorHandler'));\n            $this->smtp_conn = stream_socket_client(\n                $host . \":\" . $port,\n                $errno,\n                $errstr,\n                $timeout,\n                STREAM_CLIENT_CONNECT,\n                $socket_context\n            );\n            restore_error_handler();\n        } else {\n            //Fall back to fsockopen which should work in more places, but is missing some features\n            $this->edebug(\n                \"Connection: stream_socket_client not available, falling back to fsockopen\",\n                self::DEBUG_CONNECTION\n            );\n            set_error_handler(array($this, 'errorHandler'));\n            $this->smtp_conn = fsockopen(\n                $host,\n                $port,\n                $errno,\n                $errstr,\n                $timeout\n            );\n            restore_error_handler();\n        }\n        // Verify we connected properly\n        if (!is_resource($this->smtp_conn)) {\n            $this->setError(\n                'Failed to connect to server',\n                $errno,\n                $errstr\n            );\n            $this->edebug(\n                'SMTP ERROR: ' . $this->error['error']\n                . \": $errstr ($errno)\",\n                self::DEBUG_CLIENT\n            );\n            return false;\n        }\n        $this->edebug('Connection: opened', self::DEBUG_CONNECTION);\n        // SMTP server can take longer to respond, give longer timeout for first read\n        // Windows does not have support for this timeout function\n        if (substr(PHP_OS, 0, 3) != 'WIN') {\n            $max = ini_get('max_execution_time');\n            // Don't bother if unlimited\n            if ($max != 0 && $timeout > $max) {\n                @set_time_limit($timeout);\n            }\n            stream_set_timeout($this->smtp_conn, $timeout, 0);\n        }\n        // Get any announcement\n        $announce = $this->get_lines();\n        $this->edebug('SERVER -> CLIENT: ' . $announce, self::DEBUG_SERVER);\n        return true;\n    }\n\n    /**\n     * Initiate a TLS (encrypted) session.\n     * @access public\n     * @return boolean\n     */\n    public function startTLS()\n    {\n        if (!$this->sendCommand('STARTTLS', 'STARTTLS', 220)) {\n            return false;\n        }\n\n        //Allow the best TLS version(s) we can\n        $crypto_method = STREAM_CRYPTO_METHOD_TLS_CLIENT;\n\n        //PHP 5.6.7 dropped inclusion of TLS 1.1 and 1.2 in STREAM_CRYPTO_METHOD_TLS_CLIENT\n        //so add them back in manually if we can\n        if (defined('STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT')) {\n            $crypto_method |= STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT;\n            $crypto_method |= STREAM_CRYPTO_METHOD_TLSv1_1_CLIENT;\n        }\n\n        // Begin encrypted connection\n        set_error_handler(array($this, 'errorHandler'));\n        $crypto_ok = stream_socket_enable_crypto(\n            $this->smtp_conn,\n            true,\n            $crypto_method\n        );\n        restore_error_handler();\n        return $crypto_ok;\n    }\n\n    /**\n     * Perform SMTP authentication.\n     * Must be run after hello().\n     * @see hello()\n     * @param string $username The user name\n     * @param string $password The password\n     * @param string $authtype The auth type (PLAIN, LOGIN, NTLM, CRAM-MD5, XOAUTH2)\n     * @param string $realm The auth realm for NTLM\n     * @param string $workstation The auth workstation for NTLM\n     * @param null|OAuth $OAuth An optional OAuth instance (@see PHPMailerOAuth)\n     * @return bool True if successfully authenticated.* @access public\n     */\n    public function authenticate(\n        $username,\n        $password,\n        $authtype = null,\n        $realm = '',\n        $workstation = '',\n        $OAuth = null\n    ) {\n        if (!$this->server_caps) {\n            $this->setError('Authentication is not allowed before HELO/EHLO');\n            return false;\n        }\n\n        if (array_key_exists('EHLO', $this->server_caps)) {\n            // SMTP extensions are available; try to find a proper authentication method\n            if (!array_key_exists('AUTH', $this->server_caps)) {\n                $this->setError('Authentication is not allowed at this stage');\n                // 'at this stage' means that auth may be allowed after the stage changes\n                // e.g. after STARTTLS\n                return false;\n            }\n\n            self::edebug('Auth method requested: ' . ($authtype ? $authtype : 'UNKNOWN'), self::DEBUG_LOWLEVEL);\n            self::edebug(\n                'Auth methods available on the server: ' . implode(',', $this->server_caps['AUTH']),\n                self::DEBUG_LOWLEVEL\n            );\n\n            if (empty($authtype)) {\n                foreach (array('CRAM-MD5', 'LOGIN', 'PLAIN', 'NTLM', 'XOAUTH2') as $method) {\n                    if (in_array($method, $this->server_caps['AUTH'])) {\n                        $authtype = $method;\n                        break;\n                    }\n                }\n                if (empty($authtype)) {\n                    $this->setError('No supported authentication methods found');\n                    return false;\n                }\n                self::edebug('Auth method selected: ' . $authtype, self::DEBUG_LOWLEVEL);\n            }\n\n            if (!in_array($authtype, $this->server_caps['AUTH'])) {\n                $this->setError(\"The requested authentication method \\\"$authtype\\\" is not supported by the server\");\n                return false;\n            }\n        } elseif (empty($authtype)) {\n            $authtype = 'LOGIN';\n        }\n        switch ($authtype) {\n            case 'PLAIN':\n                // Start authentication\n                if (!$this->sendCommand('AUTH', 'AUTH PLAIN', 334)) {\n                    return false;\n                }\n                // Send encoded username and password\n                if (!$this->sendCommand(\n                    'User & Password',\n                    base64_encode(\"\\0\" . $username . \"\\0\" . $password),\n                    235\n                )\n                ) {\n                    return false;\n                }\n                break;\n            case 'LOGIN':\n                // Start authentication\n                if (!$this->sendCommand('AUTH', 'AUTH LOGIN', 334)) {\n                    return false;\n                }\n                if (!$this->sendCommand(\"Username\", base64_encode($username), 334)) {\n                    return false;\n                }\n                if (!$this->sendCommand(\"Password\", base64_encode($password), 235)) {\n                    return false;\n                }\n                break;\n            case 'XOAUTH2':\n                //If the OAuth Instance is not set. Can be a case when PHPMailer is used\n                //instead of PHPMailerOAuth\n                if (is_null($OAuth)) {\n                    return false;\n                }\n                $oauth = $OAuth->getOauth64();\n\n                // Start authentication\n                if (!$this->sendCommand('AUTH', 'AUTH XOAUTH2 ' . $oauth, 235)) {\n                    return false;\n                }\n                break;\n            case 'NTLM':\n                /*\n                 * ntlm_sasl_client.php\n                 * Bundled with Permission\n                 *\n                 * How to telnet in windows:\n                 * http://technet.microsoft.com/en-us/library/aa995718%28EXCHG.65%29.aspx\n                 * PROTOCOL Docs http://curl.haxx.se/rfc/ntlm.html#ntlmSmtpAuthentication\n                 */\n                require_once 'extras/ntlm_sasl_client.php';\n                $temp = new stdClass;\n                $ntlm_client = new ntlm_sasl_client_class;\n                //Check that functions are available\n                if (!$ntlm_client->initialize($temp)) {\n                    $this->setError($temp->error);\n                    $this->edebug(\n                        'You need to enable some modules in your php.ini file: '\n                        . $this->error['error'],\n                        self::DEBUG_CLIENT\n                    );\n                    return false;\n                }\n                //msg1\n                $msg1 = $ntlm_client->typeMsg1($realm, $workstation); //msg1\n\n                if (!$this->sendCommand(\n                    'AUTH NTLM',\n                    'AUTH NTLM ' . base64_encode($msg1),\n                    334\n                )\n                ) {\n                    return false;\n                }\n                //Though 0 based, there is a white space after the 3 digit number\n                //msg2\n                $challenge = substr($this->last_reply, 3);\n                $challenge = base64_decode($challenge);\n                $ntlm_res = $ntlm_client->NTLMResponse(\n                    substr($challenge, 24, 8),\n                    $password\n                );\n                //msg3\n                $msg3 = $ntlm_client->typeMsg3(\n                    $ntlm_res,\n                    $username,\n                    $realm,\n                    $workstation\n                );\n                // send encoded username\n                return $this->sendCommand('Username', base64_encode($msg3), 235);\n            case 'CRAM-MD5':\n                // Start authentication\n                if (!$this->sendCommand('AUTH CRAM-MD5', 'AUTH CRAM-MD5', 334)) {\n                    return false;\n                }\n                // Get the challenge\n                $challenge = base64_decode(substr($this->last_reply, 4));\n\n                // Build the response\n                $response = $username . ' ' . $this->hmac($challenge, $password);\n\n                // send encoded credentials\n                return $this->sendCommand('Username', base64_encode($response), 235);\n            default:\n                $this->setError(\"Authentication method \\\"$authtype\\\" is not supported\");\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Calculate an MD5 HMAC hash.\n     * Works like hash_hmac('md5', $data, $key)\n     * in case that function is not available\n     * @param string $data The data to hash\n     * @param string $key The key to hash with\n     * @access protected\n     * @return string\n     */\n    protected function hmac($data, $key)\n    {\n        if (function_exists('hash_hmac')) {\n            return hash_hmac('md5', $data, $key);\n        }\n\n        // The following borrowed from\n        // http://php.net/manual/en/function.mhash.php#27225\n\n        // RFC 2104 HMAC implementation for php.\n        // Creates an md5 HMAC.\n        // Eliminates the need to install mhash to compute a HMAC\n        // by Lance Rushing\n\n        $bytelen = 64; // byte length for md5\n        if (strlen($key) > $bytelen) {\n            $key = pack('H*', md5($key));\n        }\n        $key = str_pad($key, $bytelen, chr(0x00));\n        $ipad = str_pad('', $bytelen, chr(0x36));\n        $opad = str_pad('', $bytelen, chr(0x5c));\n        $k_ipad = $key ^ $ipad;\n        $k_opad = $key ^ $opad;\n\n        return md5($k_opad . pack('H*', md5($k_ipad . $data)));\n    }\n\n    /**\n     * Check connection state.\n     * @access public\n     * @return boolean True if connected.\n     */\n    public function connected()\n    {\n        if (is_resource($this->smtp_conn)) {\n            $sock_status = stream_get_meta_data($this->smtp_conn);\n            if ($sock_status['eof']) {\n                // The socket is valid but we are not connected\n                $this->edebug(\n                    'SMTP NOTICE: EOF caught while checking if connected',\n                    self::DEBUG_CLIENT\n                );\n                $this->close();\n                return false;\n            }\n            return true; // everything looks good\n        }\n        return false;\n    }\n\n    /**\n     * Close the socket and clean up the state of the class.\n     * Don't use this function without first trying to use QUIT.\n     * @see quit()\n     * @access public\n     * @return void\n     */\n    public function close()\n    {\n        $this->setError('');\n        $this->server_caps = null;\n        $this->helo_rply = null;\n        if (is_resource($this->smtp_conn)) {\n            // close the connection and cleanup\n            fclose($this->smtp_conn);\n            $this->smtp_conn = null; //Makes for cleaner serialization\n            $this->edebug('Connection: closed', self::DEBUG_CONNECTION);\n        }\n    }\n\n    /**\n     * Send an SMTP DATA command.\n     * Issues a data command and sends the msg_data to the server,\n     * finializing the mail transaction. $msg_data is the message\n     * that is to be send with the headers. Each header needs to be\n     * on a single line followed by a <CRLF> with the message headers\n     * and the message body being separated by and additional <CRLF>.\n     * Implements rfc 821: DATA <CRLF>\n     * @param string $msg_data Message data to send\n     * @access public\n     * @return boolean\n     */\n    public function data($msg_data)\n    {\n        //This will use the standard timelimit\n        if (!$this->sendCommand('DATA', 'DATA', 354)) {\n            return false;\n        }\n\n        /* The server is ready to accept data!\n         * According to rfc821 we should not send more than 1000 characters on a single line (including the CRLF)\n         * so we will break the data up into lines by \\r and/or \\n then if needed we will break each of those into\n         * smaller lines to fit within the limit.\n         * We will also look for lines that start with a '.' and prepend an additional '.'.\n         * NOTE: this does not count towards line-length limit.\n         */\n\n        // Normalize line breaks before exploding\n        $lines = explode(\"\\n\", str_replace(array(\"\\r\\n\", \"\\r\"), \"\\n\", $msg_data));\n\n        /* To distinguish between a complete RFC822 message and a plain message body, we check if the first field\n         * of the first line (':' separated) does not contain a space then it _should_ be a header and we will\n         * process all lines before a blank line as headers.\n         */\n\n        $field = substr($lines[0], 0, strpos($lines[0], ':'));\n        $in_headers = false;\n        if (!empty($field) && strpos($field, ' ') === false) {\n            $in_headers = true;\n        }\n\n        foreach ($lines as $line) {\n            $lines_out = array();\n            if ($in_headers and $line == '') {\n                $in_headers = false;\n            }\n            //Break this line up into several smaller lines if it's too long\n            //Micro-optimisation: isset($str[$len]) is faster than (strlen($str) > $len),\n            while (isset($line[self::MAX_LINE_LENGTH])) {\n                //Working backwards, try to find a space within the last MAX_LINE_LENGTH chars of the line to break on\n                //so as to avoid breaking in the middle of a word\n                $pos = strrpos(substr($line, 0, self::MAX_LINE_LENGTH), ' ');\n                //Deliberately matches both false and 0\n                if (!$pos) {\n                    //No nice break found, add a hard break\n                    $pos = self::MAX_LINE_LENGTH - 1;\n                    $lines_out[] = substr($line, 0, $pos);\n                    $line = substr($line, $pos);\n                } else {\n                    //Break at the found point\n                    $lines_out[] = substr($line, 0, $pos);\n                    //Move along by the amount we dealt with\n                    $line = substr($line, $pos + 1);\n                }\n                //If processing headers add a LWSP-char to the front of new line RFC822 section 3.1.1\n                if ($in_headers) {\n                    $line = \"\\t\" . $line;\n                }\n            }\n            $lines_out[] = $line;\n\n            //Send the lines to the server\n            foreach ($lines_out as $line_out) {\n                //RFC2821 section 4.5.2\n                if (!empty($line_out) and $line_out[0] == '.') {\n                    $line_out = '.' . $line_out;\n                }\n                $this->client_send($line_out . self::CRLF);\n            }\n        }\n\n        //Message data has been sent, complete the command\n        //Increase timelimit for end of DATA command\n        $savetimelimit = $this->Timelimit;\n        $this->Timelimit = $this->Timelimit * 2;\n        $result = $this->sendCommand('DATA END', '.', 250);\n        $this->recordLastTransactionID();\n        //Restore timelimit\n        $this->Timelimit = $savetimelimit;\n        return $result;\n    }\n\n    /**\n     * Send an SMTP HELO or EHLO command.\n     * Used to identify the sending server to the receiving server.\n     * This makes sure that client and server are in a known state.\n     * Implements RFC 821: HELO <SP> <domain> <CRLF>\n     * and RFC 2821 EHLO.\n     * @param string $host The host name or IP to connect to\n     * @access public\n     * @return boolean\n     */\n    public function hello($host = '')\n    {\n        //Try extended hello first (RFC 2821)\n        return (boolean)($this->sendHello('EHLO', $host) or $this->sendHello('HELO', $host));\n    }\n\n    /**\n     * Send an SMTP HELO or EHLO command.\n     * Low-level implementation used by hello()\n     * @see hello()\n     * @param string $hello The HELO string\n     * @param string $host The hostname to say we are\n     * @access protected\n     * @return boolean\n     */\n    protected function sendHello($hello, $host)\n    {\n        $noerror = $this->sendCommand($hello, $hello . ' ' . $host, 250);\n        $this->helo_rply = $this->last_reply;\n        if ($noerror) {\n            $this->parseHelloFields($hello);\n        } else {\n            $this->server_caps = null;\n        }\n        return $noerror;\n    }\n\n    /**\n     * Parse a reply to HELO/EHLO command to discover server extensions.\n     * In case of HELO, the only parameter that can be discovered is a server name.\n     * @access protected\n     * @param string $type - 'HELO' or 'EHLO'\n     */\n    protected function parseHelloFields($type)\n    {\n        $this->server_caps = array();\n        $lines = explode(\"\\n\", $this->helo_rply);\n\n        foreach ($lines as $n => $s) {\n            //First 4 chars contain response code followed by - or space\n            $s = trim(substr($s, 4));\n            if (empty($s)) {\n                continue;\n            }\n            $fields = explode(' ', $s);\n            if (!empty($fields)) {\n                if (!$n) {\n                    $name = $type;\n                    $fields = $fields[0];\n                } else {\n                    $name = array_shift($fields);\n                    switch ($name) {\n                        case 'SIZE':\n                            $fields = ($fields ? $fields[0] : 0);\n                            break;\n                        case 'AUTH':\n                            if (!is_array($fields)) {\n                                $fields = array();\n                            }\n                            break;\n                        default:\n                            $fields = true;\n                    }\n                }\n                $this->server_caps[$name] = $fields;\n            }\n        }\n    }\n\n    /**\n     * Send an SMTP MAIL command.\n     * Starts a mail transaction from the email address specified in\n     * $from. Returns true if successful or false otherwise. If True\n     * the mail transaction is started and then one or more recipient\n     * commands may be called followed by a data command.\n     * Implements rfc 821: MAIL <SP> FROM:<reverse-path> <CRLF>\n     * @param string $from Source address of this message\n     * @access public\n     * @return boolean\n     */\n    public function mail($from)\n    {\n        $useVerp = ($this->do_verp ? ' XVERP' : '');\n        return $this->sendCommand(\n            'MAIL FROM',\n            'MAIL FROM:<' . $from . '>' . $useVerp,\n            250\n        );\n    }\n\n    /**\n     * Send an SMTP QUIT command.\n     * Closes the socket if there is no error or the $close_on_error argument is true.\n     * Implements from rfc 821: QUIT <CRLF>\n     * @param boolean $close_on_error Should the connection close if an error occurs?\n     * @access public\n     * @return boolean\n     */\n    public function quit($close_on_error = true)\n    {\n        $noerror = $this->sendCommand('QUIT', 'QUIT', 221);\n        $err = $this->error; //Save any error\n        if ($noerror or $close_on_error) {\n            $this->close();\n            $this->error = $err; //Restore any error from the quit command\n        }\n        return $noerror;\n    }\n\n    /**\n     * Send an SMTP RCPT command.\n     * Sets the TO argument to $toaddr.\n     * Returns true if the recipient was accepted false if it was rejected.\n     * Implements from rfc 821: RCPT <SP> TO:<forward-path> <CRLF>\n     * @param string $address The address the message is being sent to\n     * @access public\n     * @return boolean\n     */\n    public function recipient($address)\n    {\n        return $this->sendCommand(\n            'RCPT TO',\n            'RCPT TO:<' . $address . '>',\n            array(250, 251)\n        );\n    }\n\n    /**\n     * Send an SMTP RSET command.\n     * Abort any transaction that is currently in progress.\n     * Implements rfc 821: RSET <CRLF>\n     * @access public\n     * @return boolean True on success.\n     */\n    public function reset()\n    {\n        return $this->sendCommand('RSET', 'RSET', 250);\n    }\n\n    /**\n     * Send a command to an SMTP server and check its return code.\n     * @param string $command The command name - not sent to the server\n     * @param string $commandstring The actual command to send\n     * @param integer|array $expect One or more expected integer success codes\n     * @access protected\n     * @return boolean True on success.\n     */\n    protected function sendCommand($command, $commandstring, $expect)\n    {\n        if (!$this->connected()) {\n            $this->setError(\"Called $command without being connected\");\n            return false;\n        }\n        //Reject line breaks in all commands\n        if (strpos($commandstring, \"\\n\") !== false or strpos($commandstring, \"\\r\") !== false) {\n            $this->setError(\"Command '$command' contained line breaks\");\n            return false;\n        }\n        $this->client_send($commandstring . self::CRLF);\n\n        $this->last_reply = $this->get_lines();\n        // Fetch SMTP code and possible error code explanation\n        $matches = array();\n        if (preg_match(\"/^([0-9]{3})[ -](?:([0-9]\\\\.[0-9]\\\\.[0-9]) )?/\", $this->last_reply, $matches)) {\n            $code = $matches[1];\n            $code_ex = (count($matches) > 2 ? $matches[2] : null);\n            // Cut off error code from each response line\n            $detail = preg_replace(\n                \"/{$code}[ -]\" .\n                ($code_ex ? str_replace('.', '\\\\.', $code_ex) . ' ' : '') . \"/m\",\n                '',\n                $this->last_reply\n            );\n        } else {\n            // Fall back to simple parsing if regex fails\n            $code = substr($this->last_reply, 0, 3);\n            $code_ex = null;\n            $detail = substr($this->last_reply, 4);\n        }\n\n        $this->edebug('SERVER -> CLIENT: ' . $this->last_reply, self::DEBUG_SERVER);\n\n        if (!in_array($code, (array)$expect)) {\n            $this->setError(\n                \"$command command failed\",\n                $detail,\n                $code,\n                $code_ex\n            );\n            $this->edebug(\n                'SMTP ERROR: ' . $this->error['error'] . ': ' . $this->last_reply,\n                self::DEBUG_CLIENT\n            );\n            return false;\n        }\n\n        $this->setError('');\n        return true;\n    }\n\n    /**\n     * Send an SMTP SAML command.\n     * Starts a mail transaction from the email address specified in $from.\n     * Returns true if successful or false otherwise. If True\n     * the mail transaction is started and then one or more recipient\n     * commands may be called followed by a data command. This command\n     * will send the message to the users terminal if they are logged\n     * in and send them an email.\n     * Implements rfc 821: SAML <SP> FROM:<reverse-path> <CRLF>\n     * @param string $from The address the message is from\n     * @access public\n     * @return boolean\n     */\n    public function sendAndMail($from)\n    {\n        return $this->sendCommand('SAML', \"SAML FROM:$from\", 250);\n    }\n\n    /**\n     * Send an SMTP VRFY command.\n     * @param string $name The name to verify\n     * @access public\n     * @return boolean\n     */\n    public function verify($name)\n    {\n        return $this->sendCommand('VRFY', \"VRFY $name\", array(250, 251));\n    }\n\n    /**\n     * Send an SMTP NOOP command.\n     * Used to keep keep-alives alive, doesn't actually do anything\n     * @access public\n     * @return boolean\n     */\n    public function noop()\n    {\n        return $this->sendCommand('NOOP', 'NOOP', 250);\n    }\n\n    /**\n     * Send an SMTP TURN command.\n     * This is an optional command for SMTP that this class does not support.\n     * This method is here to make the RFC821 Definition complete for this class\n     * and _may_ be implemented in future\n     * Implements from rfc 821: TURN <CRLF>\n     * @access public\n     * @return boolean\n     */\n    public function turn()\n    {\n        $this->setError('The SMTP TURN command is not implemented');\n        $this->edebug('SMTP NOTICE: ' . $this->error['error'], self::DEBUG_CLIENT);\n        return false;\n    }\n\n    /**\n     * Send raw data to the server.\n     * @param string $data The data to send\n     * @access public\n     * @return integer|boolean The number of bytes sent to the server or false on error\n     */\n    public function client_send($data)\n    {\n        $this->edebug(\"CLIENT -> SERVER: $data\", self::DEBUG_CLIENT);\n        set_error_handler(array($this, 'errorHandler'));\n        $result = fwrite($this->smtp_conn, $data);\n        restore_error_handler();\n        return $result;\n    }\n\n    /**\n     * Get the latest error.\n     * @access public\n     * @return array\n     */\n    public function getError()\n    {\n        return $this->error;\n    }\n\n    /**\n     * Get SMTP extensions available on the server\n     * @access public\n     * @return array|null\n     */\n    public function getServerExtList()\n    {\n        return $this->server_caps;\n    }\n\n    /**\n     * A multipurpose method\n     * The method works in three ways, dependent on argument value and current state\n     *   1. HELO/EHLO was not sent - returns null and set up $this->error\n     *   2. HELO was sent\n     *     $name = 'HELO': returns server name\n     *     $name = 'EHLO': returns boolean false\n     *     $name = any string: returns null and set up $this->error\n     *   3. EHLO was sent\n     *     $name = 'HELO'|'EHLO': returns server name\n     *     $name = any string: if extension $name exists, returns boolean True\n     *       or its options. Otherwise returns boolean False\n     * In other words, one can use this method to detect 3 conditions:\n     *  - null returned: handshake was not or we don't know about ext (refer to $this->error)\n     *  - false returned: the requested feature exactly not exists\n     *  - positive value returned: the requested feature exists\n     * @param string $name Name of SMTP extension or 'HELO'|'EHLO'\n     * @return mixed\n     */\n    public function getServerExt($name)\n    {\n        if (!$this->server_caps) {\n            $this->setError('No HELO/EHLO was sent');\n            return null;\n        }\n\n        // the tight logic knot ;)\n        if (!array_key_exists($name, $this->server_caps)) {\n            if ($name == 'HELO') {\n                return $this->server_caps['EHLO'];\n            }\n            if ($name == 'EHLO' || array_key_exists('EHLO', $this->server_caps)) {\n                return false;\n            }\n            $this->setError('HELO handshake was used. Client knows nothing about server extensions');\n            return null;\n        }\n\n        return $this->server_caps[$name];\n    }\n\n    /**\n     * Get the last reply from the server.\n     * @access public\n     * @return string\n     */\n    public function getLastReply()\n    {\n        return $this->last_reply;\n    }\n\n    /**\n     * Read the SMTP server's response.\n     * Either before eof or socket timeout occurs on the operation.\n     * With SMTP we can tell if we have more lines to read if the\n     * 4th character is '-' symbol. If it is a space then we don't\n     * need to read anything else.\n     * @access protected\n     * @return string\n     */\n    protected function get_lines()\n    {\n        // If the connection is bad, give up straight away\n        if (!is_resource($this->smtp_conn)) {\n            return '';\n        }\n        $data = '';\n        $endtime = 0;\n        stream_set_timeout($this->smtp_conn, $this->Timeout);\n        if ($this->Timelimit > 0) {\n            $endtime = time() + $this->Timelimit;\n        }\n        while (is_resource($this->smtp_conn) && !feof($this->smtp_conn)) {\n            $str = @fgets($this->smtp_conn, 515);\n            $this->edebug(\"SMTP -> get_lines(): \\$data is \\\"$data\\\"\", self::DEBUG_LOWLEVEL);\n            $this->edebug(\"SMTP -> get_lines(): \\$str is  \\\"$str\\\"\", self::DEBUG_LOWLEVEL);\n            $data .= $str;\n            // If response is only 3 chars (not valid, but RFC5321 S4.2 says it must be handled),\n            // or 4th character is a space, we are done reading, break the loop,\n            // string array access is a micro-optimisation over strlen\n            if (!isset($str[3]) or (isset($str[3]) and $str[3] == ' ')) {\n                break;\n            }\n            // Timed-out? Log and break\n            $info = stream_get_meta_data($this->smtp_conn);\n            if ($info['timed_out']) {\n                $this->edebug(\n                    'SMTP -> get_lines(): timed-out (' . $this->Timeout . ' sec)',\n                    self::DEBUG_LOWLEVEL\n                );\n                break;\n            }\n            // Now check if reads took too long\n            if ($endtime and time() > $endtime) {\n                $this->edebug(\n                    'SMTP -> get_lines(): timelimit reached (' .\n                    $this->Timelimit . ' sec)',\n                    self::DEBUG_LOWLEVEL\n                );\n                break;\n            }\n        }\n        return $data;\n    }\n\n    /**\n     * Enable or disable VERP address generation.\n     * @param boolean $enabled\n     */\n    public function setVerp($enabled = false)\n    {\n        $this->do_verp = $enabled;\n    }\n\n    /**\n     * Get VERP address generation mode.\n     * @return boolean\n     */\n    public function getVerp()\n    {\n        return $this->do_verp;\n    }\n\n    /**\n     * Set error messages and codes.\n     * @param string $message The error message\n     * @param string $detail Further detail on the error\n     * @param string $smtp_code An associated SMTP error code\n     * @param string $smtp_code_ex Extended SMTP code\n     */\n    protected function setError($message, $detail = '', $smtp_code = '', $smtp_code_ex = '')\n    {\n        $this->error = array(\n            'error' => $message,\n            'detail' => $detail,\n            'smtp_code' => $smtp_code,\n            'smtp_code_ex' => $smtp_code_ex\n        );\n    }\n\n    /**\n     * Set debug output method.\n     * @param string|callable $method The name of the mechanism to use for debugging output, or a callable to handle it.\n     */\n    public function setDebugOutput($method = 'echo')\n    {\n        $this->Debugoutput = $method;\n    }\n\n    /**\n     * Get debug output method.\n     * @return string\n     */\n    public function getDebugOutput()\n    {\n        return $this->Debugoutput;\n    }\n\n    /**\n     * Set debug output level.\n     * @param integer $level\n     */\n    public function setDebugLevel($level = 0)\n    {\n        $this->do_debug = $level;\n    }\n\n    /**\n     * Get debug output level.\n     * @return integer\n     */\n    public function getDebugLevel()\n    {\n        return $this->do_debug;\n    }\n\n    /**\n     * Set SMTP timeout.\n     * @param integer $timeout\n     */\n    public function setTimeout($timeout = 0)\n    {\n        $this->Timeout = $timeout;\n    }\n\n    /**\n     * Get SMTP timeout.\n     * @return integer\n     */\n    public function getTimeout()\n    {\n        return $this->Timeout;\n    }\n\n    /**\n     * Reports an error number and string.\n     * @param integer $errno The error number returned by PHP.\n     * @param string $errmsg The error message returned by PHP.\n     * @param string $errfile The file the error occurred in\n     * @param integer $errline The line number the error occurred on\n     */\n    protected function errorHandler($errno, $errmsg, $errfile = '', $errline = 0)\n    {\n        $notice = 'Connection failed.';\n        $this->setError(\n            $notice,\n            $errno,\n            $errmsg\n        );\n        $this->edebug(\n            $notice . ' Error #' . $errno . ': ' . $errmsg . \" [$errfile line $errline]\",\n            self::DEBUG_CONNECTION\n        );\n    }\n\n    /**\n     * Extract and return the ID of the last SMTP transaction based on\n     * a list of patterns provided in SMTP::$smtp_transaction_id_patterns.\n     * Relies on the host providing the ID in response to a DATA command.\n     * If no reply has been received yet, it will return null.\n     * If no pattern was matched, it will return false.\n     * @return bool|null|string\n     */\n    protected function recordLastTransactionID()\n    {\n        $reply = $this->getLastReply();\n\n        if (empty($reply)) {\n            $this->last_smtp_transaction_id = null;\n        } else {\n            $this->last_smtp_transaction_id = false;\n            foreach ($this->smtp_transaction_id_patterns as $smtp_transaction_id_pattern) {\n                if (preg_match($smtp_transaction_id_pattern, $reply, $matches)) {\n                    $this->last_smtp_transaction_id = $matches[1];\n                }\n            }\n        }\n\n        return $this->last_smtp_transaction_id;\n    }\n\n    /**\n     * Get the queue/transaction ID of the last SMTP transaction\n     * If no reply has been received yet, it will return null.\n     * If no pattern was matched, it will return false.\n     * @return bool|null|string\n     * @see recordLastTransactionID()\n     */\n    public function getLastTransactionID()\n    {\n        return $this->last_smtp_transaction_id;\n    }\n}\n"],"file":"class.smtp.php"}